<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Complex Function Visualization</title>
    <style>
        body {
            font-family: 'SF Pro Rounded', 'SF Pro Display', Geneva, Verdana, sans-serif;
            background: linear-gradient(125deg, #101828, #0f1419, #151a27);
            color: #ffffff;
            position: relative;
            margin: 0;
            padding: 0;
            min-height: 100vh;
            overflow-x: hidden;
        }

        body::before {
            content: ''; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background-image: radial-gradient(#ffffff18 1px, transparent 1px), radial-gradient(#ffffff0a 1.5px, transparent 1.5px);
            background-size: 28px 28px, 80px 80px; background-position: 0 0, 14px 14px;
            pointer-events: none; z-index: -1;
        }

        .page-wrapper { max-width: 1800px; margin: 0 auto; padding: 20px; position: relative; z-index: 1; }

        .top-row {
            display: flex;
            gap: 1.5rem;
            margin-bottom: 25px;
            align-items: stretch; /* MODIFIED: Was flex-start, now stretch for equal panel heights */
            flex-wrap: wrap; /* Allow wrapping on smaller screens */
        }

        .panel {
            background: rgba(16, 19, 28, 0.92); padding: 15px 20px;
            border-radius: 0.75rem;
            z-index: 10; backdrop-filter: blur(12px); -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(130, 130, 180, 0.15); box-shadow: 0 6px 20px rgba(0,0,0,0.25);
        }
        .controls-panel { 
            flex: 2; /* Give more space to controls */
            min-width: 380px; 
            max-height: 85vh; /* Max height before scrolling */
            overflow-y: auto; /* Enable vertical scrolling */
        }

        .visualization-options-panel {
            flex: 1; /* Takes up remaining space or a defined portion */
            min-width: 320px; /* Minimum width before wrapping/shrinking too much */
            max-height: 85vh; /* ADDED: Consistent max-height */
            overflow-y: auto; /* ADDED: Consistent scrolling behavior */
        }
        .panel-title-container { /* For panel title and top-right button */
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            margin-bottom: 0.8rem;
        }
        .visualization-options-panel .panel-title-container .btn-sm {
             margin-left: 1rem; /* Spacing from title */
        }


        .section-indicator {
            width: 5px; height: 16px; background: linear-gradient(to bottom, #a971ff, #7facff);
            border-radius: 3px; display: inline-block; margin-right: 0.6rem; vertical-align: middle;
            box-shadow: 0 2px 4px rgba(168, 121, 255, 0.3);
        }

        .card {
            margin-bottom: 1.5rem; background: rgba(16, 19, 28, 0.85);
            backdrop-filter: blur(15px); -webkit-backdrop-filter: blur(15px);
            border: 1px solid rgba(130, 130, 180, 0.15); border-radius: 0.75rem;
            overflow: hidden; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3); position: relative; z-index: 1;
        }
        .card::after {
            content: ''; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background-image: radial-gradient(#ffffff10 0.8px, transparent 0.8px), radial-gradient(circle at 15% 85%, rgba(168, 121, 255, 0.08), transparent 20%), radial-gradient(circle at 85% 15%, rgba(66, 133, 244, 0.06), transparent 20%);
            background-size: 24px 24px, 100% 100%, 100% 100%; pointer-events: none; z-index: -1;
        }
        .card::before {
            content: ""; position: absolute; top: 0; left: 0; right: 0; height: 1px;
            background: linear-gradient(90deg, rgba(128, 140, 156, 0) 0%, rgba(168, 121, 255, 0.3) 25%, rgba(168, 121, 255, 0.3) 75%, rgba(128, 140, 156, 0) 100%);
            z-index: 5;
        }
        .card-header {
            background: rgba(17, 21, 30, 0.8); border-bottom: 1px solid rgba(130, 130, 180, 0.15);
            padding: 0.85rem 1.15rem; color: #ffffff; position: relative; z-index: 1;
            display: flex; justify-content: space-between; align-items: center;
        }
        .card-body { padding: 0.5rem; display: flex; justify-content: center; align-items: center; position: relative; z-index: 1; }
        .panel-title {
            color: #ffffff; font-weight: 500; letter-spacing: 0.01em; font-size: 1.1rem; margin-bottom: 0;
        }

        .btn {
            display: inline-block; font-weight: 500; line-height: 1.5; text-align: center; text-decoration: none;
            vertical-align: middle; cursor: pointer; -webkit-user-select: none; -moz-user-select: none; user-select: none;
            background-color: transparent; border: 1px solid transparent; padding: 0.375rem 0.75rem;
            font-size: 1rem; border-radius: 0.375rem;
            transition: all .15s ease-in-out;
        }
        .btn-sm { padding: 0.3rem 0.6rem; font-size: .825rem; border-radius: 0.3rem; }
        .me-1 { margin-right: .25rem!important; }
        .ms-2 { margin-left: .5rem!important; }
        .me-2 { margin-right: .5rem!important; }


        .btn-primary { background: linear-gradient(to right, #a971ff, #8e68fd); border: none; box-shadow: 0 4px 15px rgba(168, 121, 255, 0.35); color: #ffffff; }
        .btn-primary:hover { background: linear-gradient(to right, #b68fff, #9b7eff); transform: translateY(-2px); box-shadow: 0 6px 20px rgba(168, 121, 255, 0.45); }
        .btn-outline-secondary { color: #e8eeff; border-color: #4d5b73; background: rgba(35, 40, 54, 0.5); backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px); }
        .btn-outline-secondary:hover { background: rgba(50, 55, 80, 0.7); color: #ffffff; border-color: #5a6478; }
        .btn-outline-secondary.active, .btn-primary.active { background: linear-gradient(to right, #a971ff, #8e68fd); color: #ffffff; border-color: transparent; box-shadow: 0 4px 15px rgba(168, 121, 255, 0.35); }

        input[type="range"] { width: 100%; margin: 8px 0; background-color: transparent; -webkit-appearance: none; appearance: none; }
        input[type=range]:focus { outline: none; }
        input[type=range]::-webkit-slider-runnable-track { width: 100%; height: 6px; cursor: pointer; background: #444b5e; border-radius: 3px; }
        input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 16px; height: 16px; background: #a971ff; cursor: pointer; border-radius: 50%; border: none; margin-top: -5px; }
        input[type=range]::-moz-range-track { width: 100%; height: 6px; cursor: pointer; background: #444b5e; border-radius: 3px; }
        input[type=range]::-moz-range-thumb { width: 16px; height: 16px; background: #a971ff; cursor: pointer; border-radius: 50%; border: none; }

        .form-label { color: #e8eeff; font-weight: 400; font-size: 0.9rem; margin-bottom: 0.1rem; display: block; } /* Reduced margin-bottom */
        .slider-value-output { font-weight: bold; color: #7facff; display: inline; margin-left: 0.25rem;}
        .form-select-sm, .animation-speed-selector {
            padding: 0.3rem 1.5rem 0.3rem 0.6rem; font-size: .825rem; border-radius: 0.3rem;
            background-color: rgba(35, 40, 54, 0.7); color: #e8eeff; border: 1px solid #4d5b73;
            background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'%3e%3cpath fill='none' stroke='%23e8eeff' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='m2 5 6 6 6-6'/%3e%3c/svg%3e");
            background-repeat: no-repeat; background-position: right 0.6rem center; background-size: 12px 12px;
            -webkit-appearance: none; -moz-appearance: none; appearance: none;
        }
        .animation-speed-selector { padding: 0.3rem 0.6rem; margin-left: 0.25rem; min-width: 60px;}
        .form-check-input { width: 1em; height: 1em; margin-top: 0.25em; vertical-align: top; background-color: #2f374a; border: 1px solid #4d5b73; -webkit-appearance: none; -moz-appearance: none; appearance: none; border-radius: 0.25em; transition: background-color .15s ease-in-out,background-position .15s ease-in-out,border-color .15s ease-in-out,box-shadow .15s ease-in-out; }
        .form-check-input:checked { background-color: #a971ff; border-color: #a971ff; background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 20 20'%3e%3cpath fill='none' stroke='%23fff' stroke-linecap='round' stroke-linejoin='round' stroke-width='3' d='m6 10 3 3 6-6'/%3e%3c/svg%3e"); }
        .form-check-label { color: #e8eeff; font-size: 0.9rem; margin-left: 0.3rem; }
        .form-check { display: flex; align-items: center; margin-bottom: 0.5rem; }


        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: rgba(19, 23, 35, 0.5); border-radius: 4px; }
        ::-webkit-scrollbar-thumb { background: rgba(130, 130, 180, 0.3); border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: rgba(168, 121, 255, 0.5); }

        code { font-family: "Courier New", Courier, monospace; background-color: rgba(255,255,255,0.1); padding: 2px 6px; border-radius: 4px; color: #c9d1ff; }
        .mb-2 { margin-bottom: .5rem!important; } .mb-3 { margin-bottom: 1rem!important; }
        .mt-2 { margin-top: .5rem!important; } .mt-3 { margin-top: 1rem!important; }

        .controls-section { margin-bottom: 1rem; }
        
        .slider-row { display: flex; flex-wrap: wrap; gap: 1rem; align-items: flex-start; margin-bottom: 0.8rem;} 
        .slider-column { flex: 1; min-width: 220px; }
        .slider-column .form-label { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; display: inline; } 

        .slider-container { display: flex; align-items: center; margin-top: 0.2rem; }
        .slider-container input[type="range"] { flex-grow: 1; }
        .slider-container .btn-sm { flex-shrink: 0; } 
        .slider-container .animation-speed-selector { flex-shrink: 0; }

        .canvas-row { 
            display: flex; 
            flex-wrap: wrap; 
            gap: 1.5rem; 
            justify-content: space-between; /* MODIFIED: Was center, now space-between for edge alignment */
        }
        .canvas-card { 
            flex: 1 1 0; /* Allow shrinking and growing from a base of 0 */
            min-width: 320px; /* Minimum width before wrapping */
            max-width: 1800px; /* Max width to prevent excessive stretching */
            position: relative; /* For probe info overlay */
        }
        canvas { 
            border-radius: 4px; display: block; margin: 0 auto; cursor: crosshair; 
            width: 100%; /* Make canvas responsive within card-body */
            height: auto; /* Maintain aspect ratio based on width */
        }
        .hidden { display: none !important; }

        .function-btn-group div { display: flex; flex-wrap: wrap; gap: 0.25rem; }

        .probe-info-overlay {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(16, 19, 28, 0.85);
            backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(130, 130, 180, 0.2);
            border-radius: 0.5rem;
            padding: 8px 12px;
            font-size: 0.8rem;
            color: #e8eeff;
            z-index: 100;
            pointer-events: none; /* Allow clicks to pass through to canvas */
            line-height: 1.4;
            max-width: calc(100% - 20px); /* Ensure it doesn't overflow small canvases */
        }
        .probe-info-overlay code { font-size: 0.75rem; }
    </style>
</head>
<body class="pb-5">
    <div class="page-wrapper">
        <div class="top-row">
            <div class="panel controls-panel">

                <div class="controls-section function-btn-group">
                    <label class="form-label d-block">Select Function:</label>
                    <div>
                        <button id="select_cos_btn" class="btn btn-sm btn-outline-secondary">w = cos(z)</button>
                        <button id="select_sin_btn" class="btn btn-sm btn-outline-secondary">w = sin(z)</button>
                        <button id="select_tan_btn" class="btn btn-sm btn-outline-secondary">w = tan(z)</button>
                        <button id="select_sec_btn" class="btn btn-sm btn-outline-secondary">w = sec(z)</button>
                        <button id="select_exp_btn" class="btn btn-sm btn-outline-secondary">w = e<sup>z</sup></button>
                        <button id="select_ln_btn" class="btn btn-sm btn-outline-secondary">w = ln(z)</button>
                        <button id="select_reciprocal_btn" class="btn btn-sm btn-outline-secondary">w = 1/z</button>
                        <button id="select_mobius_btn" class="btn btn-sm btn-outline-secondary">Möbius</button>
                        <button id="select_zeta_btn" class="btn btn-sm btn-outline-secondary">w = ζ(z)</button>
                        <button id="select_polynomial_btn" class="btn btn-sm btn-outline-secondary">Polynomial</button>
                    </div>
                </div>
                
                <!-- Placeholder for Zeta-specific controls -->
                <div id="zeta_specific_controls" class="controls-section hidden" style="margin-top: 0.5rem; margin-bottom: 0.5rem;">
                    <button id="toggle_zeta_continuation_btn" class="btn btn-sm btn-outline-secondary">Enable Analytic Continuation</button>
                </div>

                <div class="controls-section" id="common_params_sliders"> <!-- This whole div will be hidden for grid_cartesian -->
                    <div class="slider-row">
                        <div class="slider-column">
                            <label for="a0_slider" class="form-label"><span id="a0_label_desc">Real part of z (<code>a<sub>0</sub></code>):</span></label>
                            <output id="a0_value_display" class="slider-value-output">0.80</output>
                            <div class="slider-container">
                                <input type="range" id="a0_slider" min="-5" max="5" step="0.05" value="0.80">
                                <button id="play_a0_btn" class="btn btn-sm btn-outline-secondary ms-2">Play</button>
                                <select id="speed_a0_selector" class="animation-speed-selector"><option value="0.1">0.1x</option><option value="0.5">0.5x</option><option value="1" selected>1x</option><option value="2">2x</option></select>
                            </div>
                        </div>
                        <div class="slider-column">
                            <label for="b0_slider" class="form-label"><span id="b0_label_desc">Imaginary part of z (<code>b<sub>0</sub></code>):</span></label>
                            <output id="b0_value_display" class="slider-value-output">0.50</output>
                            <div class="slider-container">
                                <input type="range" id="b0_slider" min="-5" max="5" step="0.05" value="0.5">
                                <button id="play_b0_btn" class="btn btn-sm btn-outline-secondary ms-2">Play</button>
                                <select id="speed_b0_selector" class="animation-speed-selector"><option value="0.1">0.1x</option><option value="0.5">0.5x</option><option value="1" selected>1x</option><option value="2">2x</option></select>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="controls-section hidden" id="shape_params_sliders">
                    <div id="circleR_slider_group" class="hidden slider-row">
                        <div class="slider-column">
                            <label for="circleR_slider" class="form-label"><span id="circleR_label_desc">Radius (R):</span></label>
                            <output id="circleR_value_display" class="slider-value-output">1.0</output>
                            <div class="slider-container">
                                <input type="range" id="circleR_slider" min="0.1" max="3" step="0.05" value="1.0">
                                <button id="play_circleR_btn" class="btn btn-sm btn-outline-secondary ms-2">Play</button>
                                <select id="speed_circleR_selector" class="animation-speed-selector"><option value="0.1">0.1x</option><option value="0.5">0.5x</option><option value="1" selected>1x</option><option value="2">2x</option></select>
                            </div>
                        </div>
                        <div class="slider-column"></div>
                    </div>
                    <div id="ellipse_params_slider_group" class="hidden slider-row">
                        <div class="slider-column">
                            <label for="ellipseA_slider" class="form-label"><span id="ellipseA_label_desc">Semi-axis A:</span></label>
                            <output id="ellipseA_value_display" class="slider-value-output">1.5</output>
                            <div class="slider-container">
                                <input type="range" id="ellipseA_slider" min="0.1" max="3" step="0.05" value="1.5">
                                <button id="play_ellipseA_btn" class="btn btn-sm btn-outline-secondary ms-2">Play</button>
                                <select id="speed_ellipseA_selector" class="animation-speed-selector"><option value="0.1">0.1x</option><option value="0.5">0.5x</option><option value="1" selected>1x</option><option value="2">2x</option></select>
                            </div>
                        </div>
                        <div class="slider-column">
                            <label for="ellipseB_slider" class="form-label"><span id="ellipseB_label_desc">Semi-axis B:</span></label>
                            <output id="ellipseB_value_display" class="slider-value-output">0.7</output>
                            <div class="slider-container">
                                <input type="range" id="ellipseB_slider" min="0.1" max="3" step="0.05" value="0.7">
                                <button id="play_ellipseB_btn" class="btn btn-sm btn-outline-secondary ms-2">Play</button>
                                <select id="speed_ellipseB_selector" class="animation-speed-selector"><option value="0.1">0.1x</option><option value="0.5">0.5x</option><option value="1" selected>1x</option><option value="2">2x</option></select>
                            </div>
                        </div>
                    </div>
                    <div id="hyperbola_params_slider_group" class="hidden slider-row">
                        <div class="slider-column">
                            <label for="hyperbolaA_slider" class="form-label"><span id="hyperbolaA_label_desc">Param A:</span></label>
                            <output id="hyperbolaA_value_display" class="slider-value-output">1.0</output>
                            <div class="slider-container">
                                <input type="range" id="hyperbolaA_slider" min="0.1" max="2.5" step="0.05" value="1.0">
                                <button id="play_hyperbolaA_btn" class="btn btn-sm btn-outline-secondary ms-2">Play</button>
                                <select id="speed_hyperbolaA_selector" class="animation-speed-selector"><option value="0.1">0.1x</option><option value="0.5">0.5x</option><option value="1" selected>1x</option><option value="2">2x</option></select>
                            </div>
                        </div>
                        <div class="slider-column">
                             <label for="hyperbolaB_slider" class="form-label"><span id="hyperbolaB_label_desc">Param B:</span></label>
                            <output id="hyperbolaB_value_display" class="slider-value-output">0.5</output>
                            <div class="slider-container">
                            <input type="range" id="hyperbolaB_slider" min="0.1" max="2.5" step="0.05" value="0.5">
                                <button id="play_hyperbolaB_btn" class="btn btn-sm btn-outline-secondary ms-2">Play</button>
                                <select id="speed_hyperbolaB_selector" class="animation-speed-selector"><option value="0.1">0.1x</option><option value="0.5">0.5x</option><option value="1" selected>1x</option><option value="2">2x</option></select>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="controls-section hidden" id="mobius_params_sliders">
                    <label class="form-label d-block" style="margin-bottom: 0.5rem;">Möbius Parameters (w = (az+b)/(cz+d)):</label>
                    <div class="slider-row">
                        <div class="slider-column">
                            <label for="mobiusA_slider" class="form-label"><span id="mobiusA_label_desc">a:</span></label>
                            <output id="mobiusA_value_display" class="slider-value-output">1</output>
                            <div class="slider-container">
                                <input type="range" id="mobiusA_slider" min="-5" max="5" step="0.1" value="1">
                                <button id="play_mobiusA_btn" class="btn btn-sm btn-outline-secondary ms-2">Play</button>
                                <select id="speed_mobiusA_selector" class="animation-speed-selector"><option value="0.1">0.1x</option><option value="0.5">0.5x</option><option value="1" selected>1x</option><option value="2">2x</option></select>
                            </div>
                        </div>
                        <div class="slider-column">
                            <label for="mobiusB_slider" class="form-label"><span id="mobiusB_label_desc">b:</span></label>
                            <output id="mobiusB_value_display" class="slider-value-output">0</output>
                            <div class="slider-container">
                                <input type="range" id="mobiusB_slider" min="-5" max="5" step="0.1" value="0">
                                <button id="play_mobiusB_btn" class="btn btn-sm btn-outline-secondary ms-2">Play</button>
                                 <select id="speed_mobiusB_selector" class="animation-speed-selector"><option value="0.1">0.1x</option><option value="0.5">0.5x</option><option value="1" selected>1x</option><option value="2">2x</option></select>
                            </div>
                        </div>
                    </div>
                    <div class="slider-row">
                        <div class="slider-column">
                            <label for="mobiusC_slider" class="form-label"><span id="mobiusC_label_desc">c:</span></label>
                             <output id="mobiusC_value_display" class="slider-value-output">0</output>
                            <div class="slider-container">
                                <input type="range" id="mobiusC_slider" min="-5" max="5" step="0.1" value="0">
                                <button id="play_mobiusC_btn" class="btn btn-sm btn-outline-secondary ms-2">Play</button>
                                <select id="speed_mobiusC_selector" class="animation-speed-selector"><option value="0.1">0.1x</option><option value="0.5">0.5x</option><option value="1" selected>1x</option><option value="2">2x</option></select>
                            </div>
                        </div>
                        <div class="slider-column">
                            <label for="mobiusD_slider" class="form-label"><span id="mobiusD_label_desc">d:</span></label>
                            <output id="mobiusD_value_display" class="slider-value-output">1</output>
                            <div class="slider-container">
                                <input type="range" id="mobiusD_slider" min="-5" max="5" step="0.1" value="1">
                                <button id="play_mobiusD_btn" class="btn btn-sm btn-outline-secondary ms-2">Play</button>
                                <select id="speed_mobiusD_selector" class="animation-speed-selector"><option value="0.1">0.1x</option><option value="0.5">0.5x</option><option value="1" selected>1x</option><option value="2">2x</option></select>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="controls-section hidden" id="polynomial_params_sliders">
                    <label class="form-label d-block" style="margin-bottom: 0.5rem;">Polynomial: w = a<sub>0</sub>z<sup>n</sup> + a<sub>1</sub>z<sup>n-1</sup> + ... + a<sub>n</sub></label>
                    <div class="slider-row">
                        <div class="slider-column" style="min-width: 100%;"> <!-- Make N slider full width -->
                            <label for="polynomialN_slider" class="form-label">Degree (n):</label>
                            <output id="polynomialN_value_display" class="slider-value-output">2</output>
                            <div class="slider-container">
                                <input type="range" id="polynomialN_slider" min="0" max="5" step="1" value="2">
                            </div>
                        </div>
                    </div>
                    <div id="polynomial_coeffs_container" class="mt-2"></div>
                </div>
            </div>
            
            <div class="panel visualization-options-panel">
                <div class="panel-title-container">
                    <h5 class="panel-title" style="margin-bottom:0;"><span class="section-indicator"></span>Visualization Options</h5>
                    <button id="toggle_riemann_sphere_btn" class="btn btn-sm btn-outline-secondary">Toggle Riemann Sphere View</button>
                </div>

                <div class="slider-row">
                     <div class="slider-column">
                        <label for="grid_density_slider" class="form-label">Grid Density (for Grid Shape):</label>
                        <output id="grid_density_value_display" class="slider-value-output">15</output>
                        <div class="slider-container">
                            <input type="range" id="grid_density_slider" min="5" max="30" step="1" value="15">
                        </div>
                    </div>
                    <div class="slider-column">
                        <label for="neighborhood_size_slider" class="form-label">Probe Neighborhood Size (r<sub>local</sub>):</label>
                        <output id="neighborhood_size_value_display" class="slider-value-output">0.2</output>
                        <div class="slider-container">
                            <input type="range" id="neighborhood_size_slider" min="0.05" max="0.5" step="0.01" value="0.2">
                        </div>
                    </div>
                </div>
                
                <div class="slider-row mt-3">
                    <div class="slider-column">
                        <label for="z_plane_zoom_slider" class="form-label">Z-Plane Zoom:</label>
                        <output id="z_plane_zoom_value_display" class="slider-value-output">1.00</output>x
                        <div class="slider-container">
                            <input type="range" id="z_plane_zoom_slider" min="0.2" max="5" step="0.05" value="1.0">
                        </div>
                    </div>
                    <div class="slider-column">
                        <label for="w_plane_zoom_slider" class="form-label">W-Plane Zoom:</label>
                        <output id="w_plane_zoom_value_display" class="slider-value-output">1.00</output>x
                        <div class="slider-container">
                            <input type="range" id="w_plane_zoom_slider" min="0.2" max="5" step="0.05" value="1.0">
                        </div>
                    </div>
                </div>

                <div class="form-check mt-3">
                    <input class="form-check-input" type="checkbox" id="enable_domain_coloring_cb">
                    <label class="form-check-label" for="enable_domain_coloring_cb">Enable Domain Coloring (Max Detail)</label>
                </div>
                
                <div class="form-check mt-2">
                    <input class="form-check-input" type="checkbox" id="show_zeros_poles_cb">
                    <label class="form-check-label" for="show_zeros_poles_cb">Show Zeros/Poles (Approx., Planar View Only)</label>
                </div>
            </div>
        </div>


        <div class="canvas-row">
            <div class="card canvas-card">
                <div class="card-header">
                    <h5 class="panel-title mb-0"><span class="section-indicator"></span><span id="z-plane-title">z-plane (Input: <code>z = a + ib</code>)</span></h5>
                    <div style="display: flex; align-items: center;">
                        <label for="input_shape_selector" class="form-label" style="font-size:0.8rem; margin-bottom:0; margin-right:0.5rem; display:inline-block;">Shape:</label>
                        <select id="input_shape_selector" class="form-select-sm">
                            <option value="grid_cartesian" selected>Grid (Cartesian)</option>
                            <option value="line">Lines (Re/Im Fixed)</option>
                            <option value="circle">Circle</option>
                            <option value="ellipse">Ellipse</option>
                            <option value="hyperbola">Hyperbola</option>
                        </select>
                    </div>
                </div>
                <div class="card-body">
                    <canvas id="z_plane_canvas"></canvas> <!-- Removed fixed width/height -->
                    <div id="z_plane_probe_info" class="probe-info-overlay hidden"></div>
                </div>
            </div>
            <div class="card canvas-card">
                <div class="card-header">
                    <h5 class="panel-title mb-0"><span class="section-indicator"></span><span id="w-plane-title">w-plane (Output: <code id="w-plane-title-func">w = cos(z)</code>)</span></h5>
                    <div id="w_plane_analysis_info" class="me-2" style="font-size: 0.8rem; color: #7facff;"></div>
                </div>
                <div class="card-body">
                    <canvas id="w_plane_canvas"></canvas> <!-- Removed fixed width/height -->
                    <div id="w_plane_probe_info" class="probe-info-overlay hidden"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- Constants and Global Variables ---
        const COLOR_CANVAS_BACKGROUND = 'rgb(16, 20, 31)';
        const COLOR_AXES = 'rgba(130, 130, 180, 0.7)';
        const COLOR_GRID_LINES = 'rgba(130, 130, 180, 0.25)';
        const COLOR_TEXT_ON_CANVAS = '#d0d7e2';
        const COLOR_INPUT_SHAPE_Z = 'rgb(100,150,255)'; 
        const COLOR_INPUT_LINE_IM_Z = 'rgb(100,255,150)';   
        const COLOR_FOCI = 'rgb(255,100,100)';
        const COLOR_ZERO_MARKER = 'rgba(255, 60, 60, 0.9)';
        const COLOR_POLE_MARKER = 'rgba(60, 160, 255, 0.9)';
        const COLOR_PROBE_MARKER = 'rgba(255, 220, 0, 0.9)';
        const COLOR_PROBE_NEIGHBORHOOD = 'rgba(255, 220, 0, 0.5)';
        const COLOR_Z_GRID_HORZ = 'rgba(100,150,255,0.7)';
        const COLOR_Z_GRID_VERT = 'rgba(100,255,150,0.7)';
        const COLOR_SPHERE_OUTLINE = 'rgba(150, 180, 220, 0.8)';
        const COLOR_SPHERE_GRID = 'rgba(130, 130, 180, 0.3)';


        const NUM_POINTS_CURVE = 250;
        const NUM_ZETA_TERMS = 150; // For Eta series part of Zeta (general use)
        const NUM_ZETA_TERMS_FOR_FE = 200; // More terms when Eta is used inside Functional Equation
        const MAX_POLY_DEGREE = 5;
        const ZERO_POLE_EPSILON = 1e-4; 
        const ZERO_POLE_GRID_SIZE = 100; 
        const POLE_MAGNITUDE_THRESHOLD = 5e3;
        const DEFAULT_CANVAS_ASPECT_RATIO = 600/700;


        const zCanvas = document.getElementById('z_plane_canvas');
        const wCanvas = document.getElementById('w_plane_canvas');
        const zCtx = zCanvas.getContext('2d');
        const wCtx = wCanvas.getContext('2d');

        const zDomainColorCanvas = document.createElement('canvas');
        const wDomainColorCanvas = document.createElement('canvas');
        // Width/height set in setupCanvasBaseParams
        const zDomainColorCtx = zDomainColorCanvas.getContext('2d', { willReadFrequently: true });
        const wDomainColorCtx = wDomainColorCanvas.getContext('2d', { willReadFrequently: true });


        const controls = {};
        const sliderParamKeys = ['a0', 'b0', 'circleR', 'ellipseA', 'ellipseB', 'hyperbolaA', 'hyperbolaB', 'mobiusA', 'mobiusB', 'mobiusC', 'mobiusD'];
        
        sliderParamKeys.forEach(key => {
            controls[`${key}Slider`] = document.getElementById(`${key}_slider`);
            controls[`${key}ValueDisplay`] = document.getElementById(`${key}_value_display`);
            controls[`${key}LabelDesc`] = document.getElementById(`${key}_label_desc`); 
            const playBtn = document.getElementById(`play_${key}_btn`);
            if (playBtn) controls[`play_${key}Btn`] = playBtn;
            const speedSel = document.getElementById(`speed_${key}_selector`);
            if (speedSel) controls[`speed_${key}Selector`] = speedSel;
        });

        controls.commonParamsSliders = document.getElementById('common_params_sliders');
        controls.shapeParamsSliders = document.getElementById('shape_params_sliders');
        controls.mobiusParamsSliders = document.getElementById('mobius_params_sliders');
        controls.polynomialParamsSliders = document.getElementById('polynomial_params_sliders');
        controls.polynomialNSlider = document.getElementById('polynomialN_slider');
        controls.polynomialNValueDisplay = document.getElementById('polynomialN_value_display');
        controls.polynomialCoeffsContainer = document.getElementById('polynomial_coeffs_container');

        controls.circleRSliderGroup = document.getElementById('circleR_slider_group');
        controls.ellipseParamsSliderGroup = document.getElementById('ellipse_params_slider_group');
        controls.hyperbolaParamsSliderGroup = document.getElementById('hyperbola_params_slider_group');

        controls.inputShapeSelector = document.getElementById('input_shape_selector');
        controls.funcButtons = {};
        ['cos', 'sin', 'tan', 'sec', 'exp', 'ln', 'reciprocal', 'mobius', 'zeta', 'polynomial'].forEach(f => {
            controls.funcButtons[f] = document.getElementById(`select_${f}_btn`);
        });
        controls.wPlaneTitleFunc = document.getElementById('w-plane-title-func'); // This is inside w-plane-title span
        controls.zPlaneTitle = document.getElementById('z-plane-title');
        controls.wPlaneTitle = document.getElementById('w-plane-title');
        
        controls.enableDomainColoringCb = document.getElementById('enable_domain_coloring_cb');
        controls.gridDensitySlider = document.getElementById('grid_density_slider');
        controls.gridDensityValueDisplay = document.getElementById('grid_density_value_display');
        controls.showZerosPolesCb = document.getElementById('show_zeros_poles_cb');
        controls.neighborhoodSizeSlider = document.getElementById('neighborhood_size_slider');
        controls.neighborhoodSizeValueDisplay = document.getElementById('neighborhood_size_value_display');
        controls.toggleRiemannSphereBtn = document.getElementById('toggle_riemann_sphere_btn');
        controls.zPlaneProbeInfo = document.getElementById('z_plane_probe_info');
        controls.wPlaneProbeInfo = document.getElementById('w_plane_probe_info');
        controls.wPlaneAnalysisInfo = document.getElementById('w_plane_analysis_info');
        controls.zPlaneZoomSlider = document.getElementById('z_plane_zoom_slider');
        controls.zPlaneZoomValueDisplay = document.getElementById('z_plane_zoom_value_display');
        controls.wPlaneZoomSlider = document.getElementById('w_plane_zoom_slider');
        controls.wPlaneZoomValueDisplay = document.getElementById('w_plane_zoom_value_display');
        controls.toggleZetaContinuationBtn = document.getElementById('toggle_zeta_continuation_btn'); // Added
        controls.zetaSpecificControlsDiv = document.getElementById('zeta_specific_controls'); // Added


        let state = {
            a0: 0.80, b0: 0.50, 
            circleR: 1.0, ellipseA: 1.5, ellipseB: 0.7, hyperbolaA: 1.0, hyperbolaB: 0.5,
            mobiusA: 1, mobiusB: 0, mobiusC: 0, mobiusD: 1,
            polynomialN: 2,
            polynomialCoeffs: [], 
            currentFunction: 'cos',
            currentInputShape: 'grid_cartesian',
            domainColoringEnabled: false,
            gridDensity: 15, 
            showZerosPoles: false,
            probeActive: false,
            probeZ: { re: 0, im: 0 },
            probeNeighborhoodSize: 0.2,
            riemannSphereViewEnabled: false,
            zPlaneZoom: 1.0,
            wPlaneZoom: 1.0,
            zeros: [], 
            poles: [],
            zetaContinuationEnabled: false, // Added for Zeta function
        };
        
        const zPlaneInitialRanges = { x: [-3.5, 3.5], y: [-3.0, 3.0] };
        const wPlaneInitialRanges = { x: [-6.5, 6.5], y: [-6.5, 6.5] }; 
        // zPlaneParams and wPlaneParams will store current width, height, origin, scale, and current view ranges (xRange/yRange or currentVisXRange/YRange)
        const zPlaneParams = { width: 700, height: 600, origin: {}, scale: {}, currentVisXRange: [...zPlaneInitialRanges.x], currentVisYRange: [...zPlaneInitialRanges.y] };
        const wPlaneParams = { width: 700, height: 600, origin: {}, scale: {}, xRange: [...wPlaneInitialRanges.x], yRange: [...wPlaneInitialRanges.y] }; 
        
        let animationStates = {}; 
        let domainColoringDirty = true; 

        const SPHERE_VIEW_RADIUS_FACTOR = 0.85; 
        let sphereViewParams = {
            z: { rotX: 0.4, rotY: -0.6, dragging: false, lastMouseX: 0, lastMouseY: 0, radius: 0, centerX: 0, centerY: 0 },
            w: { rotX: 0.4, rotY: -0.6, dragging: false, lastMouseX: 0, lastMouseY: 0, radius: 0, centerX: 0, centerY: 0 }
        };
        const SPHERE_GRID_LINES = 20; 
        const SPHERE_SENSITIVITY = 0.01; 


        // --- Math Helpers ---
        function complexAdd(z1, z2) { return { re: z1.re + z2.re, im: z1.im + z2.im }; }
        function complexSub(z1, z2) { return { re: z1.re - z2.re, im: z1.im - z2.im }; }
        function complexMul(z1, z2) { return { re: z1.re * z2.re - z1.im * z2.im, im: z1.re * z2.im + z1.im * z2.re }; }
        function complexScalarMul(s, z) { return { re: s * z.re, im: s * z.im }; }
        function cosh(x) { return (Math.exp(x) + Math.exp(-x)) / 2; }
        function sinh(x) { return (Math.exp(x) - Math.exp(-x)) / 2; }
        function complexCos(a, b) { return { re: Math.cos(a) * cosh(b), im: -Math.sin(a) * sinh(b) }; }
        function complexSin(a, b) { return { re: Math.sin(a) * cosh(b), im: Math.cos(a) * sinh(b) }; }
        function complexExp(a,b) { return { re: Math.exp(a) * Math.cos(b), im: Math.exp(a) * Math.sin(b) }; }
        function complexDivide(num, den) {
            const den_sq_mag = den.re * den.re + den.im * den.im;
            if (Math.abs(den_sq_mag) < 1e-20) { // Increased tolerance for "zero" denominator
                const num_sq_mag = num.re * num.re + num.im * num.im;
                if (num_sq_mag < 1e-20 && den_sq_mag < 1e-24) return { re: NaN, im: NaN}; // 0/0 case, more stringent
                if (num_sq_mag < 1e-20) return { re: 0, im: 0}; 
                
                const large_val = POLE_MAGNITUDE_THRESHOLD * 2; 
                // Avoid division by zero if num_mag_sq is also tiny by checking num_sq_mag before sqrt
                if (num_sq_mag < 1e-30) return { re: Math.sign(num.re) * large_val, im: Math.sign(num.im) * large_val }; // Or handle as NaN if preferred
                const scale = large_val / Math.sqrt(num_sq_mag);
                return { re: num.re * scale, im: num.im * scale };
            }
            return { re: (num.re * den.re + num.im * den.im) / den_sq_mag, im: (num.im * den.re - num.re * den.im) / den_sq_mag };
        }
        function complexTan(a, b) { return complexDivide(complexSin(a, b), complexCos(a, b)); }
        function complexSec(a, b) { return complexDivide({ re: 1, im: 0 }, complexCos(a, b)); }
        function complexLn(a,b) { // Principal value of natural logarithm
            if (a === 0 && b === 0) { return { re: -Infinity, im: 0 }; } 
            const mod = Math.sqrt(a * a + b * b);
            const arg = Math.atan2(b, a); // Principal argument (-PI, PI]
            return { re: Math.log(mod), im: arg };
        }
        function complexReciprocal(a,b) { return complexDivide({re:1, im:0}, {re:a, im:b}); }
        function complexPow(base_re, base_im, exp_re, exp_im) { // Principal value: base^exp = exp(exp * Ln(base))
            if (base_re === 0 && base_im === 0) {
                if (exp_re > 0 || (exp_re === 0 && exp_im !== 0)) return { re: 0, im: 0 }; // 0^z = 0 for Re(z)>0
                if (exp_re === 0 && exp_im === 0) return { re: 1, im: 0}; // 0^0 = 1 convention
                const logBase = complexLn(base_re, base_im); 
                const exponent = {re: exp_re, im: exp_im};
                const product = complexMul(exponent, logBase); 
                return complexExp(product.re, product.im); 
            }
            const logBase = complexLn(base_re, base_im); 
            const exponent = {re: exp_re, im: exp_im};
            const product = complexMul(exponent, logBase); 
            return complexExp(product.re, product.im); 
        }

        // Lanczos approximation for Complex Gamma function
        const LANCZOS_G = 7;
        const LANCZOS_P = [
            0.99999999999980993, 
            676.5203681218851, 
            -1259.1392167224028, 
            771.32342877765313, 
            -176.61502916214059, 
            12.507343278686905, 
            -0.13857109526572012, 
            9.9843695780195716e-6, 
            1.5056327351493116e-7
        ];
        function complexGamma(re, im) {
            const z = { re, im };
            if (z.re < 0.5) {
                const one_minus_z = { re: 1 - z.re, im: -z.im };
                const gamma_one_minus_z = complexGamma(one_minus_z.re, one_minus_z.im);
                const pi_z_val = { re: Math.PI * z.re, im: Math.PI * z.im };
                const sin_pi_z = complexSin(pi_z_val.re, pi_z_val.im);
                const denominator = complexMul(sin_pi_z, gamma_one_minus_z);
                return complexDivide({ re: Math.PI, im: 0 }, denominator);
            }
            const z_minus_1 = { re: z.re - 1, im: z.im };
            let x = { re: LANCZOS_P[0], im: 0 };
            for (let k = 1; k < LANCZOS_P.length; k++) {
                const term_k_val = { re: LANCZOS_P[k], im: 0 };
                const z_plus_k_minus_1 = { re: z.re + k - 1, im: z.im }; // Corrected: z+k-1 for sum term z-1+k
                x = complexAdd(x, complexDivide(term_k_val, z_plus_k_minus_1));
            }
            const t = { re: z.re + LANCZOS_G - 0.5, im: z.im }; // t = z + g - 0.5
            const exp_power = { re: z.re - 0.5, im: z.im };
            const term_t_pow = complexPow(t.re, t.im, exp_power.re, exp_power.im);
            const term_exp_neg_t = complexExp(-t.re, -t.im);
            let result = complexMul(term_t_pow, term_exp_neg_t);
            result = complexMul(result, x);
            result = complexScalarMul(Math.sqrt(2 * Math.PI), result);
            return result;
        }
        
        function complexRiemannZeta_EtaSeries(a, b, numTerms) { 
            if (a === 1 && b === 0) return {re: Infinity, im: NaN};
            let eta_s = { re: 0, im: 0 };
            for (let n = 1; n <= numTerms; n++) {
                const n_pow_minus_s = complexPow(n, 0, -a, -b);
                let term = n_pow_minus_s;
                if ((n - 1) % 2 !== 0) { 
                    term = complexScalarMul(-1, term); 
                }
                eta_s = complexAdd(eta_s, term);
            }
            const one_minus_s_exp = {re: 1-a, im: -b};
            const term_2_pow_one_minus_s = complexPow(2,0, one_minus_s_exp.re, one_minus_s_exp.im);
            const denominator = complexSub({re:1, im:0}, term_2_pow_one_minus_s);

            const den_re_abs = Math.abs(denominator.re);
            const den_im_abs = Math.abs(denominator.im);
            const eta_re_abs = Math.abs(eta_s.re);
            const eta_im_abs = Math.abs(eta_s.im);

            if (den_re_abs < 1e-14 && den_im_abs < 1e-14) { 
                if (eta_re_abs < 1e-10 && eta_im_abs < 1e-10) { 
                    // This is the 0/0 case for s_k = 1 + 2kπi/ln(2), k != 0.
                    // ζ(s_k) is finite. Returning NaN breaks lines.
                    // No simple fix here without a different formula or limit computation.
                    return { re: NaN, im: NaN }; 
                }
                 const large_val = POLE_MAGNITUDE_THRESHOLD * 1.5; 
                 const eta_s_mag_sq = eta_s.re * eta_s.re + eta_s.im * eta_s.im;
                 if (eta_s_mag_sq < 1e-20) return { re: 0, im: 0};
                 const scale = large_val / Math.sqrt(eta_s_mag_sq);
                 return { re: eta_s.re * scale, im: eta_s.im * scale };
            }
            return complexDivide(eta_s, denominator);
        }

        function complexRiemannZeta(a, b) {
            const s = { re: a, im: b };

            if (s.re === 1 && s.im === 0) return { re: Infinity, im: NaN }; 
            if (s.re === 0 && s.im === 0) return { re: -0.5, im: 0 };    
            if (s.im === 0 && s.re < 0 && s.re % 2 === 0) return { re: 0, im: 0 }; // Trivial zeros

            if (state.zetaContinuationEnabled && s.re < 0.5) { // Use FE if Re(s) < 0.5
                const one_minus_s = { re: 1 - s.re, im: -s.im }; // Re(1-s) > 0.5
                
                // ζ(1-s) is computed by Eta series. Re(1-s) > 0.5, so Eta is generally better here.
                let zeta_one_minus_s = complexRiemannZeta_EtaSeries(one_minus_s.re, one_minus_s.im, NUM_ZETA_TERMS_FOR_FE);

                if (isNaN(zeta_one_minus_s.re) || isNaN(zeta_one_minus_s.im)) return {re: NaN, im: NaN};

                const two_pow_s = complexPow(2, 0, s.re, s.im);
                const pi_pow_s_minus_1 = complexPow(Math.PI, 0, s.re - 1, s.im);
                const pi_s_div_2 = { re: Math.PI * s.re / 2, im: Math.PI * s.im / 2 };
                const sin_term = complexSin(pi_s_div_2.re, pi_s_div_2.im);
                const gamma_term = complexGamma(one_minus_s.re, one_minus_s.im);

                let result = complexMul(two_pow_s, pi_pow_s_minus_1);
                result = complexMul(result, sin_term);
                result = complexMul(result, gamma_term);
                result = complexMul(result, zeta_one_minus_s);
                
                // Fallback for positive integers if functional equation results in NaN (e.g. 0 * Pole)
                if ((isNaN(result.re) || isNaN(result.im)) && (s.re > 0 && Number.isInteger(s.re) && s.im === 0)) {
                    return complexRiemannZeta_EtaSeries(s.re, s.im, NUM_ZETA_TERMS);
                }
                return result;
            } else {
                // Use Eta series directly if continuation is off OR Re(s) >= 0.5
                return complexRiemannZeta_EtaSeries(s.re, s.im, NUM_ZETA_TERMS);
            }
        }

        function complexMobius(z_re, z_im) {
            const z = {re: z_re, im: z_im};
            const term_a = {re: state.mobiusA, im: 0}; const term_b = {re: state.mobiusB, im: 0};
            const term_c = {re: state.mobiusC, im: 0}; const term_d = {re: state.mobiusD, im: 0};
            const numerator = complexAdd(complexMul(term_a, z), term_b);
            const denominator = complexAdd(complexMul(term_c, z), term_d);
            return complexDivide(numerator, denominator);
        }
        function complexPolynomial(z_re, z_im) {
            let w = { re: 0, im: 0 };
            const z = { re: z_re, im: z_im };
            for (let k = 0; k <= state.polynomialN; k++) {
                const coeff_k = state.polynomialCoeffs[k]; 
                const power = state.polynomialN - k;
                let z_pow_power;
                if (power === 0) { 
                    z_pow_power = { re: 1, im: 0 };
                } else if (z.re === 0 && z.im === 0) { 
                    z_pow_power = (power > 0) ? { re: 0, im: 0 } : {re: Infinity, im: NaN}; 
                } else {
                    z_pow_power = complexPow(z.re, z.im, power, 0);
                }
                const term = complexMul(coeff_k, z_pow_power);
                w = complexAdd(w, term);
            }
            return w;
        }
        function numericDerivative(funcName, z, h = 1e-7) {
            const func = transformFunctions[funcName];
            if (!func) return { re: NaN, im: NaN };
            const z_plus_h_real = { re: z.re + h, im: z.im };
            const z_minus_h_real = { re: z.re - h, im: z.im };
            const f_z_plus_h = func(z_plus_h_real.re, z_plus_h_real.im);
            const f_z_minus_h = func(z_minus_h_real.re, z_minus_h_real.im);
            if (isNaN(f_z_plus_h.re) || isNaN(f_z_plus_h.im) || isNaN(f_z_minus_h.re) || isNaN(f_z_minus_h.im) ||
                !isFinite(f_z_plus_h.re) || !isFinite(f_z_plus_h.im) || !isFinite(f_z_minus_h.re) || !isFinite(f_z_minus_h.im) ) {
                return { re: NaN, im: NaN };
            }
            const num = complexSub(f_z_plus_h, f_z_minus_h);
            const den = { re: 2 * h, im: 0 };
            return complexDivide(num, den);
        }

        const transformFunctions = { 
            cos: complexCos, sin: complexSin, tan: complexTan, sec: complexSec, exp: complexExp, ln: complexLn,
            reciprocal: complexReciprocal, mobius: complexMobius, zeta: complexRiemannZeta, polynomial: complexPolynomial
        };
        
        function mapToCanvasCoords(worldX, worldY, params) { return { x: params.origin.x + worldX * params.scale.x, y: params.origin.y - worldY * params.scale.y }; }
        function mapCanvasToWorldCoords(canvasX, canvasY, params) { return { x: (canvasX - params.origin.x) / params.scale.x, y: (params.origin.y - canvasY) / params.scale.y }; }

        function complexToSphere(re, im) { if(isNaN(re)||isNaN(im)||!isFinite(re)||!isFinite(im)) return {x:NaN,y:NaN,z:NaN}; const d = re*re+im*im+1; if(d===0) return {x:NaN,y:NaN,z:NaN}; return { x:2*re/d, y:2*im/d, z:(re*re+im*im-1)/d }; }
        function sphereToComplex(p3d) { if(Math.abs(p3d.z-1)<1e-9)return{re:Infinity,im:Infinity}; const den = 1-p3d.z; if(Math.abs(den)<1e-9) return {re:p3d.x > 0 ? Infinity : (p3d.x < 0 ? -Infinity : 0), im: p3d.y > 0 ? Infinity : (p3d.y < 0 ? -Infinity : 0)}; return { re:p3d.x/den, im:p3d.y/den }; }
        function rotate3D(p3D, rotX, rotY) { if(isNaN(p3D.x)) return {x:NaN,y:NaN,z:NaN}; const cY=Math.cos(rotY),sY=Math.sin(rotY),cX=Math.cos(rotX),sX=Math.sin(rotX); let x1=p3D.x*cY+p3D.z*sY,y1=p3D.y,z1=-p3D.x*sY+p3D.z*cY; return { x:x1, y:y1*cX-z1*sX, z:y1*sX+z1*cX }; }
        function inverseRotate3D(p3D_r, rotX, rotY) { if(isNaN(p3D_r.x)) return {x:NaN,y:NaN,z:NaN}; const cY=Math.cos(-rotY),sY=Math.sin(-rotY),cX=Math.cos(-rotX),sX=Math.sin(-rotX); let x1=p3D_r.x,y1=p3D_r.y*cX-p3D_r.z*sX,z1=p3D_r.y*sX+p3D_r.z*cX; return { x:x1*cY+z1*sY, y:y1, z:-x1*sY+z1*cY }; }
        function projectSphereToCanvas2D(p3D_r, sCX, sCY, sR) { if(isNaN(p3D_r.x)) return {x:NaN,y:NaN,isVisible:false}; return { x:sCX+p3D_r.x*sR, y:sCY-p3D_r.y*sR, isVisible:p3D_r.z>-1e-3 }; }

        function getHSLColor(phase, logMod, brightF=1, sat=1) { const h=((phase+Math.PI)/(2*Math.PI))*360; let l=(((logMod/Math.log(2))%1.0)*0.5)+0.25; if(logMod<-10)l=0; l=Math.max(0.1,Math.min(0.9,l)); return `hsl(${h.toFixed(1)},${sat*100}%,${l*brightF*100}%)`; }
        function hslToRgb(hslStr) { const m=hslStr.match(/hsl\((\d+\.?\d*), *(\d+\.?\d*)%, *(\d+\.?\d*)%\)/); if(!m)return{r:0,g:0,b:0}; let h=parseFloat(m[1]),s=parseFloat(m[2])/100,l=parseFloat(m[3])/100; let c=(1-Math.abs(2*l-1))*s,x=c*(1-Math.abs((h/60)%2-1)),md=l-c/2,r=0,g=0,b=0; if(0<=h&&h<60){r=c;g=x;b=0;}else if(60<=h&&h<120){r=x;g=c;b=0;}else if(120<=h&&h<180){r=0;g=c;b=x;}else if(180<=h&&h<240){r=0;g=x;b=c;}else if(240<=h&&h<300){r=x;g=0;b=c;}else if(300<=h&&h<360){r=c;g=0;b=x;} return{r:Math.round((r+md)*255),g:Math.round((g+md)*255),b:Math.round((b+md)*255)}; }

        function renderPlanarDomainColoring(targetCtx, planeParams, isWPlaneColoring, sourceTransformFunc) {
            const width = planeParams.width; const height = planeParams.height;
            if (width === 0 || height === 0) return; 
            const imageData = targetCtx.createImageData(width, height); const data = imageData.data;
            const detail = 1; 

            for (let py = 0; py < height; py += detail) {
                for (let px = 0; px < width; px += detail) {
                    const worldCoords = mapCanvasToWorldCoords(px + detail/2, py + detail/2, planeParams);
                    let valToColor;

                    if (isWPlaneColoring) { 
                        valToColor = { re: worldCoords.x, im: worldCoords.y };
                    } else { 
                        if (sourceTransformFunc) {
                            if (state.currentFunction === 'zeta' && !state.zetaContinuationEnabled && worldCoords.x <= 1.00001 && worldCoords.x >= -0.00001 && Math.abs(worldCoords.y) < 0.00001 && worldCoords.x !== 1.0) { // Special handling for Re(z) near 0, Im(z) near 0 if continuation is off
                                // This is to avoid coloring points like z=0 if it's handled differently by FE vs Eta
                                // and continuation is off. For z=0, zeta(0) = -0.5.
                                // If worldCoords.x <= 1.0 and continuation is off, Eta series is used.
                                // Eta series is valid for Re(z) > 0.
                                if (worldCoords.x <= 0) valToColor = {re: NaN, im: NaN};
                                else valToColor = sourceTransformFunc(worldCoords.x, worldCoords.y);
                            } else if (state.currentFunction === 'zeta' && !state.zetaContinuationEnabled && worldCoords.x <= 0) {
                                valToColor = {re: NaN, im: NaN};
                            }
                             else {
                                valToColor = sourceTransformFunc(worldCoords.x, worldCoords.y);
                            }
                        } else { 
                            valToColor = { re: worldCoords.x, im: worldCoords.y };
                        }
                    }
                    
                    if (isNaN(valToColor.re) || isNaN(valToColor.im) || !isFinite(valToColor.re) || !isFinite(valToColor.im)) continue;
                    const phase = Math.atan2(valToColor.im, valToColor.re);
                    const modulus = Math.sqrt(valToColor.re * valToColor.re + valToColor.im * valToColor.im);
                    const logMod = Math.log(1 + modulus); 
                    const hslColor = getHSLColor(phase, logMod);
                    const rgb = hslToRgb(hslColor);

                    for (let dy = 0; dy < detail; dy++) { 
                        for (let dx = 0; dx < detail; dx++) {
                            if (py + dy < height && px + dx < width) {
                                const idx = ((py + dy) * width + (px + dx)) * 4;
                                data[idx] = rgb.r; data[idx + 1] = rgb.g; data[idx + 2] = rgb.b; data[idx + 3] = 255;
                            }
                        }
                    }
                }
            }
            targetCtx.putImageData(imageData, 0, 0);
        }

        function renderSphereDomainColoring(targetCtx, currentSphereP, canvasDOMP, isWPlaneColoring, sourceTransformFunc) {
            const width = canvasDOMP.width; const height = canvasDOMP.height;
            if (width === 0 || height === 0) return;
            const imageData = targetCtx.createImageData(width, height); const data = imageData.data;
            const detail = 1; 
            const {centerX, centerY, radius, rotX, rotY} = currentSphereP;

            for (let py=0; py<height; py+=detail) {
                for (let px=0; px<width; px+=detail) {
                    const normX=(px+detail/2-centerX)/radius; const normY=-(py+detail/2-centerY)/radius;
                    if(normX*normX+normY*normY<=1){ 
                        const projZ=Math.sqrt(1-normX*normX-normY*normY);
                        const pRotated={x:normX,y:normY,z:projZ};
                        const pUnrotated=inverseRotate3D(pRotated,rotX,rotY);
                        let complexValForColoring;
                        const complexValFromSphere = sphereToComplex(pUnrotated);

                        if (isWPlaneColoring) { 
                           complexValForColoring = complexValFromSphere;
                        } else { 
                            if (sourceTransformFunc && !isNaN(complexValFromSphere.re) && !isNaN(complexValFromSphere.im) && isFinite(complexValFromSphere.re) && isFinite(complexValFromSphere.im)) {
                                if (state.currentFunction === 'zeta' && !state.zetaContinuationEnabled && complexValFromSphere.re <= 0) { // Changed from 1.0 to 0 for sphere
                                     complexValForColoring = {re: NaN, im: NaN};
                                } else {
                                    complexValForColoring = sourceTransformFunc(complexValFromSphere.re, complexValFromSphere.im);
                                }
                            } else {
                                complexValForColoring = {re: NaN, im: NaN}; 
                            }
                        }
                        if(isNaN(complexValForColoring.re)||isNaN(complexValForColoring.im)||!isFinite(complexValForColoring.re)||!isFinite(complexValForColoring.im)) continue;
                        const phase=Math.atan2(complexValForColoring.im,complexValForColoring.re); const modulus=Math.sqrt(complexValForColoring.re*complexValForColoring.re+complexValForColoring.im*complexValForColoring.im); const logMod=Math.log(1+modulus);
                        const hslColor=getHSLColor(phase,logMod); const rgb=hslToRgb(hslColor);
                        for(let dy=0;dy<detail;dy++){for(let dx=0;dx<detail;dx++){if(py+dy<height&&px+dx<width){const idx=((py+dy)*width+(px+dx))*4; data[idx]=rgb.r;data[idx+1]=rgb.g;data[idx+2]=rgb.b;data[idx+3]=255;}}}
                    }
                }
            }
            targetCtx.putImageData(imageData,0,0);
        }
        
        function drawAxes(ctx,params,xL,yL){ctx.save();ctx.strokeStyle=COLOR_AXES;ctx.fillStyle=COLOR_TEXT_ON_CANVAS;ctx.lineWidth=1;ctx.beginPath();const yOC=mapToCanvasCoords(0,0,params).y;ctx.moveTo(0,yOC);ctx.lineTo(params.width,yOC);const xOC=mapToCanvasCoords(0,0,params).x;ctx.moveTo(xOC,0);ctx.lineTo(xOC,params.height);ctx.stroke();ctx.font="11px 'SF Pro Text',sans-serif";ctx.textAlign="left";ctx.textBaseline="top";ctx.fillText(yL,xOC+5,5);ctx.textAlign="right";ctx.textBaseline="bottom";ctx.fillText(xL,params.width-5,yOC-5);ctx.font="10px 'SF Pro Text',sans-serif";const xTS=1,yTS=1;const cXR=params.currentVisXRange||params.xRange;const cYR=params.currentVisYRange||params.yRange;ctx.textAlign="center";ctx.textBaseline="top";const xS=Math.ceil(cXR[0]/xTS)*xTS;const xE=Math.floor(cXR[1]/xTS)*xTS;for(let xw=xS;xw<=xE+1e-6;xw+=xTS){if(Math.abs(xw)>Math.max(Math.abs(cXR[0]),Math.abs(cXR[1]))+xTS&&xw!==0)continue;const C=mapToCanvasCoords(xw,0,params);let l=xw.toFixed(0);if(Math.abs(xw)<1e-3)l="0";ctx.fillText(l,C.x,C.y+5);ctx.beginPath();ctx.moveTo(C.x,C.y-3);ctx.lineTo(C.x,C.y+3);ctx.stroke();}ctx.textAlign="right";ctx.textBaseline="middle";const yS=Math.ceil(cYR[0]/yTS)*yTS;const yE=Math.floor(cYR[1]/yTS)*yTS;for(let yw=yS;yw<=yE+1e-6;yw+=yTS){if(Math.abs(yw)>Math.max(Math.abs(cYR[0]),Math.abs(cYR[1]))+yTS&&yw!==0)continue;const C=mapToCanvasCoords(0,yw,params);let l=yw.toFixed(0);if(Math.abs(yw)<1e-3&&Math.abs(xOC-C.x)<params.width-10&&l!=="0")l="";else if(Math.abs(yw)<1e-3)l="0";if(l!=="")ctx.fillText(l,C.x-5,C.y);ctx.beginPath();ctx.moveTo(C.x-3,C.y);ctx.lineTo(C.x+3,C.y);ctx.stroke();}ctx.restore();}
        function drawGridLines(ctx,params){ctx.save();ctx.strokeStyle=COLOR_GRID_LINES;ctx.lineWidth=0.5;ctx.beginPath();const xTS=1,yTS=1;const cXR=params.currentVisXRange||params.xRange;const cYR=params.currentVisYRange||params.yRange;const xS=Math.ceil(cXR[0]/xTS)*xTS;const xE=Math.floor(cXR[1]/xTS)*xTS;for(let x=xS;x<=xE+1e-6;x+=xTS){if(Math.abs(x)>Math.max(Math.abs(cXR[0]),Math.abs(cXR[1]))+xTS&&x!==0)continue;const Cx=mapToCanvasCoords(x,0,params).x;ctx.moveTo(Cx,0);ctx.lineTo(Cx,params.height);}const yS=Math.ceil(cYR[0]/yTS)*yTS;const yE=Math.floor(cYR[1]/yTS)*yTS;for(let y=yS;y<=yE+1e-6;y+=yTS){if(Math.abs(y)>Math.max(Math.abs(cYR[0]),Math.abs(cYR[1]))+yTS&&y!==0)continue;const Cy=mapToCanvasCoords(0,y,params).y;ctx.moveTo(0,Cy);ctx.lineTo(params.width,Cy);}ctx.stroke();ctx.restore();}

        function findZerosAndPoles(){state.zeros=[];state.poles=[];if(!state.showZerosPoles||state.riemannSphereViewEnabled)return;const func=transformFunctions[state.currentFunction];const{currentVisXRange:xR,currentVisYRange:yR}=zPlaneParams;const dx=(xR[1]-xR[0])/ZERO_POLE_GRID_SIZE;const dy=(yR[1]-yR[0])/ZERO_POLE_GRID_SIZE;for(let i=0;i<=ZERO_POLE_GRID_SIZE;i++){const z_re=xR[0]+i*dx;for(let j=0;j<=ZERO_POLE_GRID_SIZE;j++){const z_im=yR[0]+j*dy;if(state.currentFunction === 'zeta' && !state.zetaContinuationEnabled && z_re <= 0){continue;}const w=func(z_re,z_im);if(isNaN(w.re)||isNaN(w.im)||!isFinite(w.re)||!isFinite(w.im))continue;const modW=Math.sqrt(w.re*w.re+w.im*w.im);if(modW<ZERO_POLE_EPSILON){let tC=state.zeros.some(z=>Math.abs(z.re-z_re)<dx*2&&Math.abs(z.im-z_im)<dy*2);if(!tC)state.zeros.push({re:z_re,im:z_im});}else if(modW>POLE_MAGNITUDE_THRESHOLD){let tC=state.poles.some(p=>Math.abs(p.re-z_re)<dx*2&&Math.abs(p.im-z_im)<dy*2);if(!tC)state.poles.push({re:z_re,im:z_im});}}}}

        function drawZPlaneContent(){zCtx.fillStyle=COLOR_CANVAS_BACKGROUND;zCtx.fillRect(0,0,zPlaneParams.width,zPlaneParams.height);const curFunc=transformFunctions[state.currentFunction];if(state.riemannSphereViewEnabled){const cSP=sphereViewParams.z;if(state.domainColoringEnabled&&domainColoringDirty){renderSphereDomainColoring(zDomainColorCtx,cSP,zPlaneParams,false,curFunc);}if(state.domainColoringEnabled){zCtx.drawImage(zDomainColorCanvas,0,0);}drawRiemannSphereBase(zCtx,cSP,zPlaneParams);drawSphereGridAndShape(zCtx,cSP,zPlaneParams,false);}else{if(state.domainColoringEnabled&&domainColoringDirty){renderPlanarDomainColoring(zDomainColorCtx,zPlaneParams,false,curFunc);}if(state.domainColoringEnabled){zCtx.drawImage(zDomainColorCanvas,0,0);}drawGridLines(zCtx,zPlaneParams);drawAxes(zCtx,zPlaneParams,"Re(z) = a","Im(z) = b");if(state.currentFunction === 'zeta' && !state.zetaContinuationEnabled && !state.riemannSphereViewEnabled){const x_boundary=0.0; const x_min_view=zPlaneParams.currentVisXRange[0];const x_max_rect=Math.min(x_boundary,zPlaneParams.currentVisXRange[1]);if(x_max_rect>x_min_view){const p1=mapToCanvasCoords(x_min_view,zPlaneParams.currentVisYRange[1],zPlaneParams);const p2=mapToCanvasCoords(x_max_rect,zPlaneParams.currentVisYRange[0],zPlaneParams);zCtx.save();zCtx.fillStyle='rgba(30,30,60,0.35)';zCtx.fillRect(p1.x,p1.y,p2.x-p1.x,p2.y-p1.y);zCtx.fillStyle='rgba(180,180,220,0.6)';zCtx.font="italic 11px 'SF Pro Text',sans-serif";zCtx.textAlign='center';const text_x_world=(x_min_view+x_max_rect)/2;if(x_max_rect-x_min_view > 50/zPlaneParams.scale.x){const text_pos_canvas=mapToCanvasCoords(text_x_world,zPlaneParams.currentVisYRange[0]+0.2*(zPlaneParams.currentVisYRange[1]-zPlaneParams.currentVisYRange[0]),zPlaneParams);zCtx.fillText("Re(z) ≤ 0 (Cont. Off)",text_pos_canvas.x,text_pos_canvas.y);}zCtx.restore();}}drawPlanarInputShape(zCtx,zPlaneParams);if(state.showZerosPoles)drawZerosAndPolesMarkers(zCtx,zPlaneParams);if(state.probeActive)drawPlanarProbe(zCtx,zPlaneParams);}}
        function drawWPlaneContent(){wCtx.fillStyle=COLOR_CANVAS_BACKGROUND;wCtx.fillRect(0,0,wPlaneParams.width,wPlaneParams.height);const curFunc=transformFunctions[state.currentFunction];if(state.riemannSphereViewEnabled){const cSP=sphereViewParams.w;if(state.domainColoringEnabled&&domainColoringDirty){renderSphereDomainColoring(wDomainColorCtx,cSP,wPlaneParams,true,curFunc);}if(state.domainColoringEnabled){wCtx.drawImage(wDomainColorCanvas,0,0);}drawRiemannSphereBase(wCtx,cSP,wPlaneParams);drawSphereGridAndShape(wCtx,cSP,wPlaneParams,true,curFunc);}else{if(state.domainColoringEnabled&&domainColoringDirty){renderPlanarDomainColoring(wDomainColorCtx,wPlaneParams,true,null);}if(state.domainColoringEnabled){wCtx.drawImage(wDomainColorCanvas,0,0);}drawGridLines(wCtx,wPlaneParams);drawAxes(wCtx,wPlaneParams,"Re(w) = X","Im(w) = Y");drawPlanarTransformedShape(wCtx,wPlaneParams,curFunc);if(state.probeActive)drawPlanarTransformedProbe(wCtx,wPlaneParams,curFunc);updateWindingNumberDisplay(curFunc);}}
        
        function drawPlanarInputShape(ctx,planeParams){ctx.save();ctx.lineWidth=2.5;const scX=state.a0,scY=state.b0;if(state.currentInputShape==='grid_cartesian'){const{currentVisXRange:xR,currentVisYRange:yR}=planeParams;const nL=state.gridDensity;ctx.strokeStyle=COLOR_Z_GRID_HORZ;for(let i=0;i<=nL;i++){const yv=yR[0]+(i/nL)*(yR[1]-yR[0]);ctx.beginPath();const ps=mapToCanvasCoords(xR[0],yv,planeParams),pe=mapToCanvasCoords(xR[1],yv,planeParams);ctx.moveTo(ps.x,ps.y);ctx.lineTo(pe.x,pe.y);ctx.stroke();}for(let i=0;i<=nL;i++){const xv=xR[0]+(i/nL)*(xR[1]-xR[0]);ctx.strokeStyle=(state.currentFunction==='zeta'&&!state.zetaContinuationEnabled&&xv<=0.0)?'rgba(100,255,150,0.25)':COLOR_Z_GRID_VERT;ctx.beginPath();const ps=mapToCanvasCoords(xv,yR[0],planeParams),pe=mapToCanvasCoords(xv,yR[1],planeParams);ctx.moveTo(ps.x,ps.y);ctx.lineTo(pe.x,pe.y);ctx.stroke();}}else if(state.currentInputShape==='line'){ctx.strokeStyle=COLOR_INPUT_SHAPE_Z;ctx.beginPath();const yb0c=mapToCanvasCoords(0,state.b0,planeParams).y,xminc=mapToCanvasCoords(planeParams.currentVisXRange[0],state.b0,planeParams).x,xmaxc=mapToCanvasCoords(planeParams.currentVisXRange[1],state.b0,planeParams).x;ctx.moveTo(xminc,yb0c);ctx.lineTo(xmaxc,yb0c);ctx.stroke();ctx.strokeStyle=COLOR_INPUT_LINE_IM_Z;ctx.beginPath();const xa0c=mapToCanvasCoords(state.a0,0,planeParams).x,yminc=mapToCanvasCoords(state.a0,planeParams.currentVisYRange[0],planeParams).y,ymaxc=mapToCanvasCoords(state.a0,planeParams.currentVisYRange[1],planeParams).y;ctx.moveTo(xa0c,yminc);ctx.lineTo(xa0c,ymaxc);ctx.stroke();}else{ctx.strokeStyle=COLOR_INPUT_SHAPE_Z;ctx.beginPath();let fPt=true;const getPts=(s)=>{let p=[];if(s==='circle'){for(let i=0;i<=NUM_POINTS_CURVE;++i){const t=(i/NUM_POINTS_CURVE)*2*Math.PI;p.push({x:scX+state.circleR*Math.cos(t),y:scY+state.circleR*Math.sin(t)});}}else if(s==='ellipse'){for(let i=0;i<=NUM_POINTS_CURVE;++i){const t=(i/NUM_POINTS_CURVE)*2*Math.PI;p.push({x:scX+state.ellipseA*Math.cos(t),y:scY+state.ellipseB*Math.sin(t)});}}else if(s==='hyperbola'){const UM=2.5;for(let i=0;i<=NUM_POINTS_CURVE/2;++i){const u=(i/(NUM_POINTS_CURVE/2))*UM-UM/2;p.push({x:scX+state.hyperbolaA*cosh(u),y:scY+state.hyperbolaB*sinh(u)});}p.push(null);for(let i=0;i<=NUM_POINTS_CURVE/2;++i){const u=(i/(NUM_POINTS_CURVE/2))*UM-UM/2;p.push({x:scX-state.hyperbolaA*cosh(u),y:scY+state.hyperbolaB*sinh(u)});}}return p;};getPts(state.currentInputShape).forEach(pt=>{if(!pt){ctx.stroke();ctx.beginPath();fPt=true;return;}const p=mapToCanvasCoords(pt.x,pt.y,planeParams);if(fPt){ctx.moveTo(p.x,p.y);fPt=false;}else{ctx.lineTo(p.x,p.y);}});ctx.stroke();}ctx.restore();}
        function drawZerosAndPolesMarkers(ctx,planeParams){state.zeros.forEach(z=>{const p=mapToCanvasCoords(z.re,z.im,planeParams);ctx.fillStyle=COLOR_ZERO_MARKER;ctx.beginPath();ctx.arc(p.x,p.y,5,0,2*Math.PI);ctx.fill();});state.poles.forEach(z=>{const p=mapToCanvasCoords(z.re,z.im,planeParams);ctx.strokeStyle=COLOR_POLE_MARKER;ctx.lineWidth=2;ctx.beginPath();ctx.moveTo(p.x-4,p.y-4);ctx.lineTo(p.x+4,p.y+4);ctx.moveTo(p.x+4,p.y-4);ctx.lineTo(p.x-4,p.y+4);ctx.stroke();});}
        function drawPlanarProbe(ctx,planeParams){const p_p_c=mapToCanvasCoords(state.probeZ.re,state.probeZ.im,planeParams);ctx.fillStyle=COLOR_PROBE_MARKER;ctx.beginPath();ctx.arc(p_p_c.x,p_p_c.y,5,0,2*Math.PI);ctx.fill();ctx.strokeStyle=COLOR_PROBE_NEIGHBORHOOD;ctx.lineWidth=1.5;ctx.beginPath();const r_l=state.probeNeighborhoodSize;for(let i=0;i<=60;++i){const a=(i/60)*2*Math.PI;const z_b={re:state.probeZ.re+r_l*Math.cos(a),im:state.probeZ.im+r_l*Math.sin(a)};const p_c=mapToCanvasCoords(z_b.re,z_b.im,planeParams);if(i===0)ctx.moveTo(p_c.x,p_c.y);else ctx.lineTo(p_c.x,p_c.y);}ctx.closePath();ctx.stroke();}
        function drawPlanarTransformedLine(ctx,planeParams,tf,z_pts,col){ctx.strokeStyle=col;ctx.beginPath();let fV=true;for(const z_pt of z_pts){let w;if(state.currentFunction==='zeta'&&!state.zetaContinuationEnabled&&z_pt.re<=0.0){w={re:NaN,im:NaN};}else{w=tf(z_pt.re,z_pt.im);}if(isNaN(w.re)||isNaN(w.im)||!isFinite(w.re)||!isFinite(w.im)||Math.abs(w.re)>planeParams.xRange[1]*5||Math.abs(w.im)>planeParams.yRange[1]*5){if(!fV)ctx.stroke();ctx.beginPath();fV=true;continue;}const p_c=mapToCanvasCoords(w.re,w.im,planeParams);if(fV){ctx.moveTo(p_c.x,p_c.y);fV=false;}else{ctx.lineTo(p_c.x,p_c.y);}}if(!fV)ctx.stroke();}
        function drawPlanarTransformedShape(ctx,planeParams,tf){ctx.save();ctx.lineWidth=2.5;if(state.currentInputShape==='grid_cartesian'){const{currentVisXRange:zxR,currentVisYRange:zyR}=zPlaneParams;const nL=state.gridDensity;const pPL=100;for(let i=0;i<=nL;++i){const yv=zyR[0]+(i/nL)*(zyR[1]-zyR[0]);let zlp=[];for(let j=0;j<=pPL;++j)zlp.push({re:zxR[0]+(j/pPL)*(zxR[1]-zxR[0]),im:yv});drawPlanarTransformedLine(ctx,planeParams,tf,zlp,COLOR_Z_GRID_HORZ);}for(let i=0;i<=nL;++i){const xv=zxR[0]+(i/nL)*(zxR[1]-zxR[0]);let zlp=[];for(let j=0;j<=pPL;++j)zlp.push({re:xv,im:zyR[0]+(j/pPL)*(zyR[1]-zyR[0])});drawPlanarTransformedLine(ctx,planeParams,tf,zlp,COLOR_Z_GRID_VERT);}}else if(state.currentInputShape==='line'){if((state.currentFunction==='cos'||state.currentFunction==='sin')){ctx.save();ctx.fillStyle=COLOR_FOCI;const f1c=mapToCanvasCoords(1,0,planeParams),f2c=mapToCanvasCoords(-1,0,planeParams);ctx.beginPath();ctx.arc(f1c.x,f1c.y,4,0,2*Math.PI);ctx.fill();ctx.beginPath();ctx.arc(f2c.x,f2c.y,4,0,2*Math.PI);ctx.fill();ctx.font="10px 'SF Pro Text',sans-serif";ctx.textAlign="center";ctx.fillStyle=COLOR_TEXT_ON_CANVAS;ctx.fillText("Foci: ±1",planeParams.origin.x,f1c.y+(f1c.y<20?15:-10));ctx.restore();}let hz_pts=[];for(let i=0;i<=NUM_POINTS_CURVE;++i)hz_pts.push({re:zPlaneParams.currentVisXRange[0]+i*(zPlaneParams.currentVisXRange[1]-zPlaneParams.currentVisXRange[0])/NUM_POINTS_CURVE,im:state.b0});drawPlanarTransformedLine(ctx,planeParams,tf,hz_pts,COLOR_INPUT_SHAPE_Z);let vz_pts=[];for(let i=0;i<=NUM_POINTS_CURVE;++i)vz_pts.push({re:state.a0,im:zPlaneParams.currentVisYRange[0]+i*(zPlaneParams.currentVisYRange[1]-zPlaneParams.currentVisYRange[0])/NUM_POINTS_CURVE});drawPlanarTransformedLine(ctx,planeParams,tf,vz_pts,COLOR_INPUT_LINE_IM_Z);}else{const scX=state.a0,scY=state.b0;let z_pts=[];if(state.currentInputShape==='circle'){for(let i=0;i<=NUM_POINTS_CURVE;++i){const t=(i/NUM_POINTS_CURVE)*2*Math.PI;z_pts.push({re:scX+state.circleR*Math.cos(t),im:scY+state.circleR*Math.sin(t)});}}else if(state.currentInputShape==='ellipse'){for(let i=0;i<=NUM_POINTS_CURVE;++i){const t=(i/NUM_POINTS_CURVE)*2*Math.PI;z_pts.push({re:scX+state.ellipseA*Math.cos(t),im:scY+state.ellipseB*Math.sin(t)});}}else if(state.currentInputShape==='hyperbola'){const UM=2.5;for(let i=0;i<=NUM_POINTS_CURVE/2;++i){const u=(i/(NUM_POINTS_CURVE/2))*UM-UM/2;z_pts.push({re:scX+state.hyperbolaA*cosh(u),im:scY+state.hyperbolaB*sinh(u)});}z_pts.push({re:NaN,im:NaN});for(let i=0;i<=NUM_POINTS_CURVE/2;++i){const u=(i/(NUM_POINTS_CURVE/2))*UM-UM/2;z_pts.push({re:scX-state.hyperbolaA*cosh(u),im:scY+state.hyperbolaB*sinh(u)});}}drawPlanarTransformedLine(ctx,planeParams,tf,z_pts,COLOR_INPUT_SHAPE_Z);}ctx.restore();}
        function drawPlanarTransformedProbe(ctx,planeParams,tf){const pW=tf(state.probeZ.re,state.probeZ.im);if(!isNaN(pW.re)&&!isNaN(pW.im)&&isFinite(pW.re)&&isFinite(pW.im)){const p_p_c=mapToCanvasCoords(pW.re,pW.im,planeParams);ctx.fillStyle=COLOR_PROBE_MARKER;ctx.beginPath();ctx.arc(p_p_c.x,p_p_c.y,5,0,2*Math.PI);ctx.fill();}ctx.strokeStyle=COLOR_PROBE_NEIGHBORHOOD;ctx.lineWidth=1.5;ctx.beginPath();const r_l=state.probeNeighborhoodSize;let fPt=true;for(let i=0;i<=60;++i){const a=(i/60)*2*Math.PI;const z_b={re:state.probeZ.re+r_l*Math.cos(a),im:state.probeZ.im+r_l*Math.sin(a)};const w_b=tf(z_b.re,z_b.im);if(isNaN(w_b.re)||isNaN(w_b.im)||!isFinite(w_b.re)||!isFinite(w_b.im)||Math.abs(w_b.re)>planeParams.xRange[1]*5||Math.abs(w_b.im)>planeParams.yRange[1]*5){if(!fPt)ctx.stroke();ctx.beginPath();fPt=true;continue;}const p_c=mapToCanvasCoords(w_b.re,w_b.im,planeParams);if(fPt){ctx.moveTo(p_c.x,p_c.y);fPt=false;}else{ctx.lineTo(p_c.x,p_c.y);}}if(!fPt){ctx.closePath();ctx.stroke();}}
        function updateWindingNumberDisplay(tf){controls.wPlaneAnalysisInfo.textContent='';if(state.currentFunction==='polynomial'&&state.currentInputShape==='circle'){let tac=0,pwarg=null;const Nwpt=100;const scX=state.a0,scY=state.b0;for(let i=0;i<=Nwpt;++i){const t=(i/Nwpt)*2*Math.PI;const z={re:scX+state.circleR*Math.cos(t),im:scY+state.circleR*Math.sin(t)};const w=tf(z.re,z.im);if(isNaN(w.re)||isNaN(w.im)||!isFinite(w.re)||!isFinite(w.im))continue;const warg=Math.atan2(w.im,w.re);if(pwarg!==null){let darg=warg-pwarg;if(darg>Math.PI)darg-=2*Math.PI;if(darg<-Math.PI)darg+=2*Math.PI;tac+=darg;}pwarg=warg;}controls.wPlaneAnalysisInfo.textContent=`Winding Number (w=0): ${Math.round(tac/(2*Math.PI))}`;}}
        
        function drawRiemannSphereBase(ctx,cSP,cDOMP){const{centerX:cX,centerY:cY,radius:r}=cSP;ctx.save();ctx.strokeStyle=COLOR_SPHERE_OUTLINE;ctx.lineWidth=1.5;ctx.beginPath();ctx.arc(cX,cY,r,0,2*Math.PI);ctx.stroke();ctx.restore();}
        function drawSphereGridAndShape(ctx,cSP,cDOMP,isWP,tf=null){const{centerX:cX,centerY:cY,radius:r,rotX,rotY}=cSP;const zpgd=state.gridDensity;const pps=state.currentInputShape==='grid_cartesian'?50:NUM_POINTS_CURVE;const drawMappedLineSet=(z_pts_src_arr,col)=>{ctx.strokeStyle=col;ctx.lineWidth=isWP?2:1.5;z_pts_src_arr.forEach(z_pts_src=>{ctx.beginPath();let fVCp=true;let lPp=null;for(const z_orig of z_pts_src){let pCmplx;let skipDrawingPoint=false;if(state.currentFunction==='zeta'&&!state.zetaContinuationEnabled&&z_orig.re<=0.0){skipDrawingPoint=true;}if(isWP){pCmplx=skipDrawingPoint?{re:NaN,im:NaN}:tf(z_orig.re,z_orig.im);}else{pCmplx=skipDrawingPoint?{re:NaN,im:NaN}:z_orig;}if(isNaN(pCmplx.re)||isNaN(pCmplx.im)||!isFinite(pCmplx.re)||!isFinite(pCmplx.im)){if(lPp&&lPp.isVisible&&!fVCp)ctx.stroke();ctx.beginPath();fVCp=true;lPp=null;continue;}const pS=complexToSphere(pCmplx.re,pCmplx.im);const pSR=rotate3D(pS,rotX,rotY);const pCv=projectSphereToCanvas2D(pSR,cX,cY,r);if(pCv.isVisible){if(lPp&&!lPp.isVisible){if(!fVCp)ctx.stroke();ctx.beginPath();ctx.moveTo(pCv.x,pCv.y);}else if(fVCp){ctx.moveTo(pCv.x,pCv.y);}else{ctx.lineTo(pCv.x,pCv.y);}fVCp=false;}else{if(lPp&&lPp.isVisible){ctx.lineTo(pCv.x,pCv.y);ctx.stroke();ctx.beginPath();}fVCp=true;}lPp=pCv;}if(lPp&&lPp.isVisible&&!fVCp)ctx.stroke();});};let z_p_s_t_m=[];const scX=state.a0,scY=state.b0;if(state.currentInputShape==='grid_cartesian'){const{currentVisXRange:zxR,currentVisYRange:zyR}=zPlaneParams;const nL=zpgd;for(let i=0;i<=nL;i++){const yv=zyR[0]+(i/nL)*(zyR[1]-zyR[0]);let lps=[];for(let j=0;j<=pps;j++)lps.push({re:zxR[0]+(j/pps)*(zxR[1]-zxR[0]),im:yv});z_p_s_t_m.push({points:lps,color:isWP?COLOR_Z_GRID_HORZ:COLOR_SPHERE_GRID});}for(let i=0;i<=nL;i++){const xv=zxR[0]+(i/nL)*(zxR[1]-zxR[0]);let lps=[];for(let j=0;j<=pps;j++)lps.push({re:xv,im:zyR[0]+(j/pps)*(zyR[1]-zyR[0])});z_p_s_t_m.push({points:lps,color:isWP?COLOR_Z_GRID_VERT:COLOR_SPHERE_GRID});}}else if(state.currentInputShape==='line'){let hzp=[];for(let i=0;i<=pps;++i)hzp.push({re:zPlaneParams.currentVisXRange[0]+i*(zPlaneParams.currentVisXRange[1]-zPlaneParams.currentVisXRange[0])/pps,im:state.b0});z_p_s_t_m.push({points:hzp,color:isWP?COLOR_INPUT_SHAPE_Z:COLOR_SPHERE_GRID});let vzp=[];for(let i=0;i<=pps;++i)vzp.push({re:state.a0,im:zPlaneParams.currentVisYRange[0]+i*(zPlaneParams.currentVisYRange[1]-zPlaneParams.currentVisYRange[0])/pps});z_p_s_t_m.push({points:vzp,color:isWP?COLOR_INPUT_LINE_IM_Z:COLOR_SPHERE_GRID});}else{let spm=[],spa=null;if(state.currentInputShape==='circle'){for(let i=0;i<=pps;++i){const t=(i/pps)*2*Math.PI;spm.push({re:scX+state.circleR*Math.cos(t),im:scY+state.circleR*Math.sin(t)});}}else if(state.currentInputShape==='ellipse'){for(let i=0;i<=pps;++i){const t=(i/pps)*2*Math.PI;spm.push({re:scX+state.ellipseA*Math.cos(t),im:scY+state.ellipseB*Math.sin(t)});}}else if(state.currentInputShape==='hyperbola'){const UM=2.5;spa=[];for(let i=0;i<=pps/2;++i){const u=(i/(pps/2))*UM-UM/2;spm.push({re:scX+state.hyperbolaA*cosh(u),im:scY+state.hyperbolaB*sinh(u)});}for(let i=0;i<=pps/2;++i){const u=(i/(pps/2))*UM-UM/2;spa.push({re:scX-state.hyperbolaA*cosh(u),im:scY+state.hyperbolaB*sinh(u)});}}z_p_s_t_m.push({points:spm,color:isWP?COLOR_INPUT_SHAPE_Z:COLOR_SPHERE_GRID});if(spa)z_p_s_t_m.push({points:spa,color:isWP?COLOR_INPUT_SHAPE_Z:COLOR_SPHERE_GRID});}z_p_s_t_m.forEach(s=>drawMappedLineSet([s.points],s.color));}

        function initializePolynomialCoeffs(n,pE=false){const oC=pE?[...state.polynomialCoeffs]:[];state.polynomialCoeffs=[];for(let i=0;i<=n;i++){if(pE&&i<oC.length&&oC[i]!==undefined)state.polynomialCoeffs.push(oC[i]);else state.polynomialCoeffs.push({re:(i===0||(i===n&&n>0&&n!==1))?1:0,im:0});}if(n===0&&state.polynomialCoeffs.length>0){if(!(pE&&oC.length>0&&oC[0]!==undefined))state.polynomialCoeffs[0]={re:1,im:0};}else if(n===0&&state.polynomialCoeffs.length===0)state.polynomialCoeffs.push({re:1,im:0});}
        function generatePolynomialCoeffSliders(){if(!controls.polynomialCoeffsContainer)return;controls.polynomialCoeffsContainer.innerHTML='';Object.keys(animationStates).forEach(k=>{if(k.startsWith('poly_coeff_')){if(animationStates[k].frameId)cancelAnimationFrame(animationStates[k].frameId);delete animationStates[k];}});for(let k=0;k<=state.polynomialN;++k){const c=state.polynomialCoeffs[k]||{re:0,im:0};const r=document.createElement('div');r.className='slider-row';const reC=document.createElement('div');reC.className='slider-column';reC.innerHTML=`<label for="poly_coeff_Re_${k}_slider" class="form-label">Re(a<sub>${k}</sub>):</label><output id="poly_coeff_Re_${k}_value_display" class="slider-value-output">${c.re.toFixed(1)}</output><div class="slider-container"><input type="range" id="poly_coeff_Re_${k}_slider" min="-5" max="5" step="0.1" value="${c.re}"><button id="play_poly_coeff_Re_${k}_btn" class="btn btn-sm btn-outline-secondary ms-2">Play</button><select id="speed_poly_coeff_Re_${k}_selector" class="animation-speed-selector"><option value="0.1">0.1x</option><option value="0.5">0.5x</option><option value="1" selected>1x</option><option value="2">2x</option></select></div>`;r.appendChild(reC);const imC=document.createElement('div');imC.className='slider-column';imC.innerHTML=`<label for="poly_coeff_Im_${k}_slider" class="form-label">Im(a<sub>${k}</sub>):</label><output id="poly_coeff_Im_${k}_value_display" class="slider-value-output">${c.im.toFixed(1)}</output><div class="slider-container"><input type="range" id="poly_coeff_Im_${k}_slider" min="-5" max="5" step="0.1" value="${c.im}"><button id="play_poly_coeff_Im_${k}_btn" class="btn btn-sm btn-outline-secondary ms-2">Play</button><select id="speed_poly_coeff_Im_${k}_selector" class="animation-speed-selector"><option value="0.1">0.1x</option><option value="0.5">0.5x</option><option value="1" selected>1x</option><option value="2">2x</option></select></div>`;r.appendChild(imC);controls.polynomialCoeffsContainer.appendChild(r);const reS=document.getElementById(`poly_coeff_Re_${k}_slider`),reP=document.getElementById(`play_poly_coeff_Re_${k}_btn`),reSp=document.getElementById(`speed_poly_coeff_Re_${k}_selector`);reS.addEventListener('input',()=>{state.polynomialCoeffs[k].re=parseFloat(reS.value);domainColoringDirty=true;redrawAll();});reP.addEventListener('click',()=>toggleAnimation(reS,'',reP,reSp,true,k,'re'));const imS=document.getElementById(`poly_coeff_Im_${k}_slider`),imP=document.getElementById(`play_poly_coeff_Im_${k}_btn`),imSp=document.getElementById(`speed_poly_coeff_Im_${k}_selector`);imS.addEventListener('input',()=>{state.polynomialCoeffs[k].im=parseFloat(imS.value);domainColoringDirty=true;redrawAll();});imP.addEventListener('click',()=>toggleAnimation(imS,'',imP,imSp,true,k,'im'));}}
        function updatePolynomialCoeffDisplays(){if(state.currentFunction!=='polynomial'||!state.polynomialCoeffs)return;for(let k=0;k<=state.polynomialN;++k){if(state.polynomialCoeffs[k]){const reD=document.getElementById(`poly_coeff_Re_${k}_value_display`);const imD=document.getElementById(`poly_coeff_Im_${k}_value_display`);if(reD)reD.textContent=state.polynomialCoeffs[k].re.toFixed(1);if(imD)imD.textContent=state.polynomialCoeffs[k].im.toFixed(1);}}}
        
        function updateSliderLabelsAndDisplay() {
            const isLine = state.currentInputShape === 'line';
            const isGridCartesian = state.currentInputShape === 'grid_cartesian';
            const isMobiusFunc = state.currentFunction === 'mobius';
            const isPolyFunc = state.currentFunction === 'polynomial';

            controls.commonParamsSliders.classList.toggle('hidden', isGridCartesian); 
            controls.mobiusParamsSliders.classList.toggle('hidden', !isMobiusFunc);
            controls.polynomialParamsSliders.classList.toggle('hidden', !isPolyFunc);

            const hideShapeSpecificSliders = isLine || isGridCartesian || isPolyFunc; 
            controls.shapeParamsSliders.classList.toggle('hidden', hideShapeSpecificSliders);

            if (!hideShapeSpecificSliders) {
                controls.circleRSliderGroup.classList.toggle('hidden', state.currentInputShape !== 'circle');
                controls.ellipseParamsSliderGroup.classList.toggle('hidden', state.currentInputShape !== 'ellipse');
                controls.hyperbolaParamsSliderGroup.classList.toggle('hidden', state.currentInputShape !== 'hyperbola');
            } else {
                controls.circleRSliderGroup.classList.add('hidden');
                controls.ellipseParamsSliderGroup.classList.add('hidden');
                controls.hyperbolaParamsSliderGroup.classList.add('hidden');
            }

            sliderParamKeys.forEach(k => {
                if (controls[`${k}ValueDisplay`] && state[k] !== undefined) {
                    const v = state[k];
                    const s = controls[`${k}Slider`];
                    const st = s ? parseFloat(s.step) : 0.1;
                    const p = st.toString().includes('.') ? st.toString().split('.')[1].length : 0;
                    controls[`${k}ValueDisplay`].textContent = v.toFixed(Math.max(p, (k === 'a0' || k === 'b0' || k === 'circleR' ? 2 : 1)));
                }
            });
            
            if (!isGridCartesian) {
                if (isLine) {
                    if (controls.a0LabelDesc) controls.a0LabelDesc.innerHTML = `Fixed Re(z) (<code>a<sub>0</sub></code>):`;
                    if (controls.b0LabelDesc) controls.b0LabelDesc.innerHTML = `Fixed Im(z) (<code>b<sub>0</sub></code>):`;
                } else { 
                    if (controls.a0LabelDesc) controls.a0LabelDesc.innerHTML = `Center X (<code>c<sub>x</sub></code>):`;
                    if (controls.b0LabelDesc) controls.b0LabelDesc.innerHTML = `Center Y (<code>c<sub>y</sub></code>):`;
                }
            }


            if (isPolyFunc) {
                if (controls.polynomialNValueDisplay) controls.polynomialNValueDisplay.textContent = state.polynomialN;
                updatePolynomialCoeffDisplays();
            }

            if (controls.gridDensityValueDisplay) controls.gridDensityValueDisplay.textContent = state.gridDensity;
            if (controls.neighborhoodSizeValueDisplay) controls.neighborhoodSizeValueDisplay.textContent = state.probeNeighborhoodSize.toFixed(2);
            if (controls.zPlaneZoomValueDisplay) controls.zPlaneZoomValueDisplay.textContent = state.zPlaneZoom.toFixed(2);
            if (controls.wPlaneZoomValueDisplay) controls.wPlaneZoomValueDisplay.textContent = state.wPlaneZoom.toFixed(2);
        }

        function updateProbeInfo(){if(state.probeActive&&!state.riemannSphereViewEnabled){const z_str=`z = ${state.probeZ.re.toFixed(3)} + ${state.probeZ.im.toFixed(3)}i`;controls.zPlaneProbeInfo.innerHTML=z_str;controls.zPlaneProbeInfo.classList.remove('hidden');const tf=transformFunctions[state.currentFunction];const pW=tf(state.probeZ.re,state.probeZ.im);let w_info="";if(!isNaN(pW.re)&&!isNaN(pW.im)&&isFinite(pW.re)&&isFinite(pW.im)){w_info+=`w = ${pW.re.toFixed(3)} + ${pW.im.toFixed(3)}i<br>`;const deriv=numericDerivative(state.currentFunction,state.probeZ);if(!isNaN(deriv.re)&&!isNaN(deriv.im)&&isFinite(deriv.re)&&isFinite(deriv.im)){w_info+=`f'(z) ≈ ${deriv.re.toFixed(3)} + ${deriv.im.toFixed(3)}i<br>`;const mag=Math.sqrt(deriv.re*deriv.re+deriv.im*deriv.im);const arg_r=Math.atan2(deriv.im,deriv.re);const arg_d=arg_r*180/Math.PI;w_info+=`|f'(z)| ≈ ${mag.toFixed(3)} (mag.)<br>`;w_info+=`arg(f'(z)) ≈ ${arg_r.toFixed(3)}rad (${arg_d.toFixed(2)}°) (rot.)`;}else{w_info+=`f'(z) calculation failed.`}}else{w_info=`w is undefined or infinite.`}controls.wPlaneProbeInfo.innerHTML=w_info;controls.wPlaneProbeInfo.classList.remove('hidden');}else{controls.zPlaneProbeInfo.classList.add('hidden');controls.wPlaneProbeInfo.classList.add('hidden');}}
        function updateTitlesAndGlobalUI(){updateSliderLabelsAndDisplay();updateProbeInfo();let fND;if(state.currentFunction==='polynomial')fND=`P(z) (deg ${state.polynomialN})`;else if(state.currentFunction==='exp')fND='e<sup>z</sup>';else if(state.currentFunction==='ln')fND='ln(z)';else if(state.currentFunction==='reciprocal')fND='1/z';else if(state.currentFunction==='mobius')fND='(az+b)/(cz+d)';else if(state.currentFunction==='zeta')fND='ζ(z)';else fND=`${state.currentFunction}(z)`;const wPlaneTitleFuncEl = document.getElementById('w-plane-title-func'); if(state.riemannSphereViewEnabled){controls.zPlaneTitle.innerHTML='z-sphere (Input)';controls.wPlaneTitle.innerHTML=`w-sphere (Output: <code id="w-plane-title-func">w = ${fND}</code>)`;}else{controls.zPlaneTitle.innerHTML=`z-plane (Input: <code>z = a + ib</code>)`;controls.wPlaneTitle.innerHTML=`w-plane (Output: <code id="w-plane-title-func">w = ${fND}</code>)`;} if(wPlaneTitleFuncEl) wPlaneTitleFuncEl.innerHTML = `w = ${fND}`; controls.inputShapeSelector.disabled=state.riemannSphereViewEnabled;if(controls.zetaSpecificControlsDiv){if(state.currentFunction==='zeta'){controls.zetaSpecificControlsDiv.classList.remove('hidden');controls.toggleZetaContinuationBtn.textContent=state.zetaContinuationEnabled?'Disable Analytic Continuation':'Enable Analytic Continuation';controls.toggleZetaContinuationBtn.classList.toggle('active',state.zetaContinuationEnabled);controls.toggleZetaContinuationBtn.classList.toggle('btn-primary',state.zetaContinuationEnabled);controls.toggleZetaContinuationBtn.classList.toggle('btn-outline-secondary',!state.zetaContinuationEnabled);}else{controls.zetaSpecificControlsDiv.classList.add('hidden');}}}
        let redrawRequest=null;function requestRedrawAll(){if(!redrawRequest){redrawRequest=requestAnimationFrame(()=>{if(state.showZerosPoles&&!state.riemannSphereViewEnabled)findZerosAndPoles();drawZPlaneContent();drawWPlaneContent();updateTitlesAndGlobalUI();domainColoringDirty=false;redrawRequest=null;});}}
        function redrawAll(){if(state.showZerosPoles&&!state.riemannSphereViewEnabled)findZerosAndPoles();drawZPlaneContent();drawWPlaneContent();updateTitlesAndGlobalUI();domainColoringDirty=false;}
        function toggleAnimation(sE,sK,pB,sS,iPC=false,pCI=-1,pCP=''){const sId=sE.id;if(!animationStates[sId])animationStates[sId]={animating:false,frameId:null,direction:1,currentAnimatedValue:parseFloat(sE.value)};let aS=animationStates[sId];if(aS.animating){aS.animating=false;if(aS.frameId)cancelAnimationFrame(aS.frameId);pB.textContent='Play';pB.classList.remove('btn-primary','active');pB.classList.add('btn-outline-secondary');}else{aS.animating=true;aS.currentAnimatedValue=parseFloat(sE.value);const min=parseFloat(sE.min),max=parseFloat(sE.max);if(aS.currentAnimatedValue>=max)aS.direction=-1;else if(aS.currentAnimatedValue<=min)aS.direction=1;else aS.direction=aS.direction||1;pB.textContent='Pause';pB.classList.add('btn-primary','active');pB.classList.remove('btn-outline-secondary');function animLoop(){if(!aS.animating)return;let iV=aS.currentAnimatedValue;const stS=parseFloat(sE.step),cM=parseFloat(sE.min),cMX=parseFloat(sE.max),spM=parseFloat(sS.value);iV+=stS*aS.direction*spM;if(iV>=cMX){iV=cMX;aS.direction=-1;}else if(iV<=cM){iV=cM;aS.direction=1;}aS.currentAnimatedValue=iV;const pr=sE.step.includes('.')?sE.step.split('.')[1].length:0;const dV=iV.toFixed(pr);sE.value=dV;const nDV=parseFloat(dV);if(iPC){if(state.polynomialCoeffs[pCI])state.polynomialCoeffs[pCI][pCP]=nDV;}else{state[sK]=nDV;}domainColoringDirty=true;requestRedrawAll();aS.frameId=requestAnimationFrame(animLoop);}animLoop();}}
        
        sliderParamKeys.forEach(k=>{if(controls[`${k}Slider`]){controls[`${k}Slider`].addEventListener('input',()=>{state[k]=parseFloat(controls[`${k}Slider`].value);domainColoringDirty=true;redrawAll();});if(controls[`play_${k}Btn`]&&controls[`speed_${k}Selector`]){controls[`play_${k}Btn`].addEventListener('click',()=>toggleAnimation(controls[`${k}Slider`],k,controls[`play_${k}Btn`],controls[`speed_${k}Selector`]));}}});
        Object.keys(controls.funcButtons).forEach(k=>{controls.funcButtons[k].addEventListener('click',()=>{state.currentFunction=k;Object.keys(controls.funcButtons).forEach(k=>{controls.funcButtons[k].classList.remove('active','btn-primary');controls.funcButtons[k].classList.add('btn-outline-secondary');});controls.funcButtons[k].classList.add('active','btn-primary');controls.funcButtons[k].classList.remove('btn-outline-secondary');domainColoringDirty=true;redrawAll();});});
        controls.inputShapeSelector.addEventListener('change',(e)=>{state.currentInputShape=e.target.value;domainColoringDirty=true;redrawAll();});
        if(controls.polynomialNSlider){controls.polynomialNSlider.addEventListener('input',()=>{const nN=parseInt(controls.polynomialNSlider.value);state.polynomialN=nN;initializePolynomialCoeffs(nN,true);generatePolynomialCoeffSliders();domainColoringDirty=true;redrawAll();});}
        controls.enableDomainColoringCb.addEventListener('change',(e)=>{state.domainColoringEnabled=e.target.checked;domainColoringDirty=true;redrawAll();});
        controls.gridDensitySlider.addEventListener('input',()=>{state.gridDensity=parseInt(controls.gridDensitySlider.value);redrawAll();});
        controls.showZerosPolesCb.addEventListener('change',(e)=>{state.showZerosPoles=e.target.checked;if(state.showZerosPoles&&!state.riemannSphereViewEnabled)findZerosAndPoles();redrawAll();});
        controls.neighborhoodSizeSlider.addEventListener('input',()=>{state.probeNeighborhoodSize=parseFloat(controls.neighborhoodSizeSlider.value);redrawAll();});
        controls.zPlaneZoomSlider.addEventListener('input', ()=>{ state.zPlaneZoom = parseFloat(controls.zPlaneZoomSlider.value); domainColoringDirty = true; setupVisualParameters(); redrawAll(); });
        controls.wPlaneZoomSlider.addEventListener('input', ()=>{ state.wPlaneZoom = parseFloat(controls.wPlaneZoomSlider.value); domainColoringDirty = true; setupVisualParameters(); redrawAll(); });
        
        controls.toggleRiemannSphereBtn.addEventListener('click',()=>{state.riemannSphereViewEnabled=!state.riemannSphereViewEnabled;controls.toggleRiemannSphereBtn.textContent=state.riemannSphereViewEnabled?"Switch to Planar View":"Toggle Riemann Sphere View";controls.toggleRiemannSphereBtn.classList.toggle('active',state.riemannSphereViewEnabled);controls.toggleRiemannSphereBtn.classList.toggle('btn-primary',state.riemannSphereViewEnabled);controls.toggleRiemannSphereBtn.classList.toggle('btn-outline-secondary',!state.riemannSphereViewEnabled);domainColoringDirty=true;redrawAll();});
        controls.toggleZetaContinuationBtn.addEventListener('click',()=>{state.zetaContinuationEnabled=!state.zetaContinuationEnabled;domainColoringDirty=true;redrawAll();});
        zCanvas.addEventListener('mousemove',(e)=>{if(state.riemannSphereViewEnabled)return;const r=zCanvas.getBoundingClientRect();const cX=e.clientX-r.left,cY=e.clientY-r.top;const wC=mapCanvasToWorldCoords(cX,cY,zPlaneParams);state.probeZ={re:wC.x,im:wC.y};state.probeActive=true;if(animationStates.isDraggingProbe)requestRedrawAll();else{updateProbeInfo();drawZPlaneContent();drawWPlaneContent();}});
        zCanvas.addEventListener('mousedown',(e)=>{if(state.riemannSphereViewEnabled)return;animationStates.isDraggingProbe=true;requestRedrawAll();});
        document.addEventListener('mouseup',()=>{if(state.riemannSphereViewEnabled)return;if(animationStates.isDraggingProbe){animationStates.isDraggingProbe=false;requestRedrawAll();}});
        zCanvas.addEventListener('mouseleave',()=>{if(state.riemannSphereViewEnabled)return;if(!animationStates.isDraggingProbe){state.probeActive=false;requestRedrawAll();}});
        function handleSphereMouseDown(e,pT){if(!state.riemannSphereViewEnabled)return;const sP=pT==='z'?sphereViewParams.z:sphereViewParams.w;sP.dragging=true;sP.lastMouseX=e.clientX;sP.lastMouseY=e.clientY;const c=pT==='z'?zCanvas:wCanvas;c.style.cursor='grabbing';}
        function handleSphereMouseMove(e,pT){if(!state.riemannSphereViewEnabled)return;const sP=pT==='z'?sphereViewParams.z:sphereViewParams.w;if(sP.dragging){const dx=e.clientX-sP.lastMouseX,dy=e.clientY-sP.lastMouseY;sP.rotY+=dx*SPHERE_SENSITIVITY;sP.rotX+=dy*SPHERE_SENSITIVITY;sP.rotX=Math.max(-Math.PI/2+0.1,Math.min(Math.PI/2-0.1,sP.rotX));sP.lastMouseX=e.clientX;sP.lastMouseY=e.clientY;domainColoringDirty=true;requestRedrawAll();}}
        function handleSphereMouseUp(pT){if(!state.riemannSphereViewEnabled)return;const sP=pT==='z'?sphereViewParams.z:sphereViewParams.w;sP.dragging=false;const c=pT==='z'?zCanvas:wCanvas;c.style.cursor='crosshair';}
        zCanvas.addEventListener('mousedown',(e)=>handleSphereMouseDown(e,'z'));zCanvas.addEventListener('mousemove',(e)=>handleSphereMouseMove(e,'z'));zCanvas.addEventListener('mouseup',()=>handleSphereMouseUp('z'));zCanvas.addEventListener('mouseleave',()=>handleSphereMouseUp('z'));
        wCanvas.addEventListener('mousedown',(e)=>handleSphereMouseDown(e,'w'));wCanvas.addEventListener('mousemove',(e)=>handleSphereMouseMove(e,'w'));wCanvas.addEventListener('mouseup',()=>handleSphereMouseUp('w'));wCanvas.addEventListener('mouseleave',()=>handleSphereMouseUp('w'));

        function setupCanvasBaseParams(planeParams, canvasElement, sphereViewObj) {
            const cardBody = canvasElement.closest('.card-body');
            let newWidth = 700; let newHeight = 600; // Defaults
            if (cardBody && cardBody.clientWidth > 50) {
                newWidth = cardBody.clientWidth;
                newHeight = newWidth * DEFAULT_CANVAS_ASPECT_RATIO;
            }
            canvasElement.width = newWidth; canvasElement.height = newHeight;
            planeParams.width = canvasElement.width; planeParams.height = canvasElement.height;
            
            sphereViewObj.radius = Math.min(planeParams.width, planeParams.height) / 2 * SPHERE_VIEW_RADIUS_FACTOR;
            sphereViewObj.centerX = planeParams.width / 2; sphereViewObj.centerY = planeParams.height / 2;
            
            const offscreenCanvas = (canvasElement === zCanvas) ? zDomainColorCanvas : wDomainColorCanvas;
            offscreenCanvas.width = planeParams.width; offscreenCanvas.height = planeParams.height;
        }
        function setupVisualParameters() { 
            setupCanvasBaseParams(zPlaneParams, zCanvas, sphereViewParams.z);
            setupCanvasBaseParams(wPlaneParams, wCanvas, sphereViewParams.w);

            const pZ = zPlaneParams; const zoomZ = state.zPlaneZoom;
            const iXSpanZ = (zPlaneInitialRanges.x[1] - zPlaneInitialRanges.x[0]) / zoomZ;
            const iYSpanZ = (zPlaneInitialRanges.y[1] - zPlaneInitialRanges.y[0]) / zoomZ;
            const iXCenterZ = (zPlaneInitialRanges.x[0] + zPlaneInitialRanges.x[1]) / 2;
            const iYCenterZ = (zPlaneInitialRanges.y[0] + zPlaneInitialRanges.y[1]) / 2;
            pZ.currentVisXRange[0] = iXCenterZ - iXSpanZ / 2; pZ.currentVisXRange[1] = iXCenterZ + iXSpanZ / 2;
            pZ.currentVisYRange[0] = iYCenterZ - iYSpanZ / 2; pZ.currentVisYRange[1] = iYCenterZ + iYSpanZ / 2;
            let scaleXZ = pZ.width / (pZ.currentVisXRange[1] - pZ.currentVisXRange[0]);
            let scaleYZ = pZ.height / (pZ.currentVisYRange[1] - pZ.currentVisYRange[0]);
            pZ.scale.x = pZ.scale.y = Math.min(scaleXZ, scaleYZ);
            const wVWZ = pZ.width / pZ.scale.x; const wVHZ = pZ.height / pZ.scale.y;
            pZ.currentVisXRange[0] = iXCenterZ - wVWZ / 2; pZ.currentVisXRange[1] = iXCenterZ + wVWZ / 2;
            pZ.currentVisYRange[0] = iYCenterZ - wVHZ / 2; pZ.currentVisYRange[1] = iYCenterZ + wVHZ / 2;
            pZ.origin.x = (pZ.width / 2) - iXCenterZ * pZ.scale.x; pZ.origin.y = (pZ.height / 2) + iYCenterZ * pZ.scale.y;

            const pW = wPlaneParams; const zoomW = state.wPlaneZoom;
            const iXCenterW = (wPlaneInitialRanges.x[0] + wPlaneInitialRanges.x[1]) / 2;
            const iYCenterW = (wPlaneInitialRanges.y[0] + wPlaneInitialRanges.y[1]) / 2;
            const iXSpanW = (wPlaneInitialRanges.x[1] - wPlaneInitialRanges.x[0]) / zoomW;
            const iYSpanW = (wPlaneInitialRanges.y[1] - wPlaneInitialRanges.y[0]) / zoomW;
            pW.xRange[0] = iXCenterW - iXSpanW / 2; pW.xRange[1] = iXCenterW + iXSpanW / 2;
            pW.yRange[0] = iYCenterW - iYSpanW / 2; pW.yRange[1] = iYCenterW + iYSpanW / 2;
            let scaleXW = pW.width / (pW.xRange[1] - pW.xRange[0]);
            let scaleYW = pW.height / (pW.yRange[1] - pW.yRange[0]);
            pW.scale.x = pW.scale.y = Math.min(scaleXW, scaleYW);
            const wVWW = pW.width / pW.scale.x; const wVHW = pW.height / pW.scale.y;
            pW.xRange[0] = iXCenterW - wVWW / 2; pW.xRange[1] = iXCenterW + wVWW / 2;
            pW.yRange[0] = iYCenterW - wVHW / 2; pW.yRange[1] = iYCenterW + wVHW / 2;
            pW.origin.x = (pW.width / 2) - iXCenterW * pW.scale.x; 
            pW.origin.y = (pW.height / 2) + iYCenterW * pW.scale.y; 
        }

        function setup() {
            setupVisualParameters(); 
            
            sliderParamKeys.forEach(k=>{if(controls[`${k}Slider`])state[k]=parseFloat(controls[`${k}Slider`].value);});
            state.gridDensity=parseInt(controls.gridDensitySlider.value);
            state.probeNeighborhoodSize=parseFloat(controls.neighborhoodSizeSlider.value);
            state.domainColoringEnabled=controls.enableDomainColoringCb.checked;
            state.showZerosPoles=controls.showZerosPolesCb.checked;
            state.zPlaneZoom = parseFloat(controls.zPlaneZoomSlider.value); 
            state.wPlaneZoom = parseFloat(controls.wPlaneZoomSlider.value); 
            state.polynomialN=parseInt(controls.polynomialNSlider.value);
            initializePolynomialCoeffs(state.polynomialN,false); generatePolynomialCoeffSliders();
            Object.keys(controls.funcButtons).forEach(k=>{controls.funcButtons[k].classList.remove('active','btn-primary');controls.funcButtons[k].classList.add('btn-outline-secondary');});
            if(controls.funcButtons[state.currentFunction]){controls.funcButtons[state.currentFunction].classList.add('active','btn-primary');controls.funcButtons[state.currentFunction].classList.remove('btn-outline-secondary');}
            else{controls.funcButtons['cos'].classList.add('active','btn-primary');controls.funcButtons['cos'].classList.remove('btn-outline-secondary');state.currentFunction='cos';}
            controls.inputShapeSelector.value = state.currentInputShape;
            domainColoringDirty = true; redrawAll();
        }
        window.addEventListener('load', setup);
        window.addEventListener('resize', () => { 
            setupVisualParameters(); 
            domainColoringDirty = true; 
            redrawAll();
        });

    </script>
</body>
</html>
